## 数组

### 1、leetcode0088 合并两个有序数组 (简单)

给你两个按 非递减顺序排列的整数数组nums1和nums2，另有两个整数m和n，分别表示nums1和nums2中的元素数目。请你合并nums2到nums1中，使合并后的数组同样按非递减顺序排列。

注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。

解法1：归并

此题考察了归并排序中的归并处理，通过一个缓存空间buffer保存nums1，然后按照归并处理将buffer和nums2的合并结果保存至nums1中。

时间复杂度为O(m + n)，空间复杂度也为O(m + n)

```c++
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        vector<int> buffer = nums1;
        int left = 0;
        int right = 0;
        for (int i = 0; i < nums1.size(); ++i) {
            if (right >= n || (left < m && buffer[left] <= nums2[right])) {
                nums1[i] = buffer[left++];
            } else {
                nums1[i] = nums2[right++];
            }
        }
    }
};
```

解法2：数组从尾到前遍历

时间复杂度为O(m + n)，空间复杂度也为O(1)

```c++
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int x = m - 1;
        int y = n - 1;
        for (int i = m + n - 1; i >= 0; --i) {
            if (y < 0 || (x >= 0 && nums1[x] >= nums2[y])) {
                nums1[i] = nums1[x--];
            } else {
                nums1[i] = nums2[y--];
            }
        }
    }
};
```

### 2、leetcode0066 加一 (简单)

给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。你可以假设除了整数 0 之外，这个整数不会以零开头。

解法：对于整数加1，主要是要考虑进位。解题步骤如下：

1. 将最后一位整数和1进行相加，分别得到最后一位的结果和进位值；
2. 从数组的倒数第二位开始往前遍历数组，将整数分别和进位值相加，如果进位值为0，则停止遍历返回结果。
3. 遍历结束后，如果进位值为0，直接返回结果，如果进位值为1，则在数组开头加入1后返回结果。

```c++
class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
        int result = digits.back() + 1;
        digits.back() = result % 10;
        int carry = result / 10;
        
        for (int i = static_cast<int>(digits.size()) - 2; i >= 0; --i) {
            if (carry == 0) {
                return digits;
            }
            result = digits[i] + carry;
            digits[i] = result % 10;
            carry = result / 10;
        }

        if (carry == 0) {
            return digits;
        }

        digits.insert(digits.begin(), 1);

        return digits;
    }
};
```

看到其他更好的解题思路，由于最后一位加1和进位加1的效果一致，那么可以直接在数组中从后往前进行遍历。解题思路如下：

1. 从后往前遍历数组，将每个整数与1相加，将相加后的结果与10进行求余，如果求余后的值不为0，则直接返回结果，否则继续遍历；
2. 当遍历结束后，如果数组首位的结果为0，那么需要在数组头部加入一个整数1，否则直接返回结果。

```c++
class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
        for (int i = digits.size() - 1; i >= 0; --i) {
            ++digits[i];  // 个数位加1或者进位加1
            digits[i] %= 10;
            if (digits[i] != 0) {
                return digits;
            }
        }
        if (digits.front() == 0) {
            digits.insert(digits.begin(), 1);
        }
        return digits;
    }
};
```







## 链表

### 1、leetcode0206 反转链表 (简单)

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

解法1：迭代

```c++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* pre = nullptr;
        while (head != nullptr) {
            ListNode* next = head->next;
            head->next = pre;
            pre = head;
            head = next;
        }
        return pre;
    }
};
```

解法2：递归

```c
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (head == nullptr || head->next == nullptr) {
            return head;
        }

        ListNode* res = reverseList(head->next);
        head->next->next = head;
        head->next = nullptr;

        return res;
    }
};
```

### 2、leetcode0025 K 个一组翻转链表（困难）

给你链表的头节点head，每 k 个节点一组进行翻转，请你返回修改后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。

解法：

在本题中按照K个一组对链表进行翻转，那么首先需要按序找到一组K个链表节点，然后这组链表节点进行翻转，最后将不同组的结果进行合并。代码如下：

```c++
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        // 设置头部哑结点，处理归一
        ListNode* dummy = new ListNode(0, head);
        ListNode* prev = dummy;

        while (head != nullptr) {
            // 1. 按照k个节点进行分组
            ListNode* tail = getTailNodeInGroup(head, k);
            if (tail == nullptr) {
                break;  // 若尾部的节点个数小于k个，退出循环
            }

            ListNode* nextGroupHead = tail->next;  // 先获取下一组待处理的头节点
            reverseNodeInGroup(head, nextGroupHead);  // 2. 反转本组的k个节点

            // 3. 更新每组和前一组、后一组的节点关系
            head->next = nextGroupHead;  // 和后一组创建关系
            prev->next = tail;  // 和前一组创建关系

            prev = head;  // 重置prev节点
            head = nextGroupHead;  // 重置head节点
        }

        ListNode* res = dummy->next;
        delete dummy;  
        
        return res;
    }

    ListNode* getTailNodeInGroup(ListNode* head, int k) {
        while (head != nullptr) {
            --k;
            if (k == 0) {
                return head;
            }
            head = head->next;
        }

        return nullptr;
    }

    void reverseNodeInGroup(ListNode* head, ListNode* stop) {
        ListNode* prev = head;
        head = head->next;
        while (head != stop) {
            ListNode* next = head->next;
            head->next = prev;
            prev = head;
            head = next;
        }
    }
};
```

### 3、leetcode0021 合并两个有序链表（简单）

将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

解法1：迭代

```c++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode* dummy = new ListNode();
        ListNode* result = dummy;
        while ((list1 != nullptr) || (list2 != nullptr)) {
            if (list2 == nullptr || (list1 != nullptr && list1->val <= list2->val)) {
                dummy->next = list1;
                list1 = list1->next;
            } else {
                dummy->next = list2;
                list2 = list2->next;
            }
            dummy = dummy->next;
        }

        return result->next;
    }
};
```

解法2：递归

```c++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        if (list1 == nullptr) {
            return list2;
        }

        if (list2 == nullptr) {
            return list1;
        }

        if (list1->val <= list2->val) {
            list1->next = mergeTwoLists(list1->next, list2);
            return list1;
        }

        list2->next = mergeTwoLists(list1, list2->next);
        return list2;
    }
};
```

## 栈

### 1、leetcode0020 有效的括号（简单）

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。有效字符串需满足：

左括号必须用相同类型的右括号闭合。

左括号必须以正确的顺序闭合。

每个右括号都有一个对应的相同类型的左括号。

解法1：通过栈保存左括号，并通过“最近相关性”来判断最近的左括号与右括号是否匹配。代码如下：

```c++
class Solution {
public:
    bool isValid(string s) {
        stack<char> buffer{};
        for (auto c : s) {
            if (c == '(' || c == '{' || c == '[') {
                buffer.push(c);
            } else {
                if (buffer.empty()) {
                    return false;
                }
                if (c == ')' && buffer.top() != '(') {
                    return false;
                }
                if (c == '}' && buffer.top() != '{') {
                    return false;
                }
                if (c == ']' && buffer.top() != '[') {
                    return false;
                }
                buffer.pop();
            }
        }
        return buffer.empty();
    }
};
```

### 2、leetcode0155 最小栈（中等）

设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。实现 MinStack 类:

MinStack() 初始化堆栈对象。
void push(int val) 将元素val推入堆栈。
void pop() 删除堆栈顶部的元素。
int top() 获取堆栈顶部的元素。
int getMin() 获取堆栈中的最小元素。

解法：本题的关键点是如何保存最小元素，并且要在常数时间内检索到最小元素。因此，需要通过另外一个栈辅助保存最小元素。

```c++
class MinStack {
public:
    MinStack() {}
    
    void push(int val) {
        data_buffer_.push(val);
        if (min_buffer_.empty()) {
            min_buffer_.push(val);
        } else {
            min_buffer_.push(min(min_buffer_.top(), val));
        }
    }
    
    void pop() {
        data_buffer_.pop();
        min_buffer_.pop();
    }
    
    int top() {
        return data_buffer_.top();
    }
    
    int getMin() {
        return min_buffer_.top();
    }

private:
    stack<int> data_buffer_;  // 保存插入数据
    stack<int> min_buffer_;  // 保存最小元素，并且和data_buffer_保持一一对应的关系
};
```

### 3、leetcode0150 逆波兰表达式求值（中等）

根据 逆波兰表示法，求表达式的值。有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。注意：两个整数之间的除法只保留整数部分。

可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。

解法：

当扫描到运算符时，需要获取最近的两个数，那么比较适合通过栈来保存数据。如果遇到数，则将其压入到栈。如果遇到运算符，则取出栈顶的两个数进行计算，然后把结果压入栈。时间复杂度为O(n)

```c++
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<int> buffer{};
        for (const auto& str : tokens) {
            if (isOperator(str)) {
                int y = buffer.top();
                buffer.pop();
                int x = buffer.top();
                buffer.pop();
                buffer.push(calculate(x, y, str));
            } else {
                buffer.push(stoi(str));
            }
        }
        return buffer.top();
    }

    bool isOperator(const string& str) const {
        return (str == "+") || (str == "-") || (str == "*") || (str == "/");
    }

    long calculate(int x, int y, const string& oper) {
        if (oper == "+") {
            return x + y;
        }
        if (oper == "-") {
            return x - y;
        }
        if (oper == "*") {
            return static_cast<long>(x) * y;  // 注意需要转换整数的长度，避免两个数相乘后超过最大值
        }
        return x / y;
    }
};
```

## 队列

### 1、leetcode0641 设计循环双端队列（中等）

设计实现双端队列。实现 MyCircularDeque 类:

```
MyCircularDeque(int k) ：构造函数,双端队列最大为 k 。
boolean insertFront()：将一个元素添加到双端队列头部。 如果操作成功返回 true ，否则返回 false 。
boolean insertLast() ：将一个元素添加到双端队列尾部。如果操作成功返回 true ，否则返回 false 。
boolean deleteFront() ：从双端队列头部删除一个元素。 如果操作成功返回 true ，否则返回 false 。
boolean deleteLast() ：从双端队列尾部删除一个元素。如果操作成功返回 true ，否则返回 false 。
int getFront() )：从双端队列头部获得一个元素。如果双端队列为空，返回 -1 。
int getRear() ：获得双端队列的最后一个元素。 如果双端队列为空，返回 -1 。
boolean isEmpty() ：若双端队列为空，则返回 true ，否则返回 false  。
boolean isFull() ：若双端队列满了，则返回 true ，否则返回 false 。
```

解法1：由于本题中k的取值范围为[1, 1000]，值的范围不大，可通过数组实现双端队列。代码如下：

```c++
class MyCircularDeque {
private:
    vector<int> buffer_;
    int start_;
    int end_;

public:
    MyCircularDeque(int k) {
        buffer_ = vector(k + 1, 0);
        start_ = 0;
        end_ = 0;
    }
    
    bool insertFront(int value) {
        if (isFull()) {
            return false;
        }

        start_ = (start_ == 0) ? (buffer_.size() - 1) : (start_ - 1);
        buffer_[start_] = value;

        return true;
    }
    
    bool insertLast(int value) {
        if (isFull()) {
            return false;
        }

        buffer_[end_] = value;
        end_ = (end_ + 1) % buffer_.size();

        return true;
    }
    
    bool deleteFront() {
        if (isEmpty()) {
            return false;
        }

        start_ = (start_ + 1) % buffer_.size();

        return true;
    }
    
    bool deleteLast() {
        if (isEmpty()) {
            return false;
        }

        end_ = (end_ == 0) ? (buffer_.size() - 1) : (end_ - 1);

        return true;
    }
    
    int getFront() {
        return isEmpty() ? -1 : buffer_[start_];
    }
    
    int getRear() {
        if (isEmpty()) {
            return -1;
        }

        int index = (end_ == 0) ? (buffer_.size() - 1) : (end_ - 1);
        return buffer_[index];
    }
    
    bool isEmpty() {
        return (start_ == end_);
    }
    
    bool isFull() {
        return ((end_ + 1) % buffer_.size() == start_);
    }
};
```



## 单调栈

### 1、leetcode0084 柱状图中最大的矩形（困难）

给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。

解法1：暴力求解

针对每一个柱子，分别向左和向右找到最后一个高于等于该柱子高度的柱子作为边界，这样就为该柱子对应的最大矩形。但是该算法的时间复杂度为O(n^2)，如果柱状图中所有的柱子高度相等，那么算法执行会超时。

解法2：单调栈

如果柱状图一直递增，那么每个柱子对应的最大矩形只能向右找。若维护一个单调栈，栈内所保存的柱子的高度是单调递减的，当处理的柱子高度低于栈顶的柱子高度时，那么可求出栈顶柱子的最大矩形面积。

在这中间需要注意两个点，一个是宽度的累积，由于栈顶的柱子高度值最大，那么其可用于非栈顶元素的最大矩形求解，同时也用于待入栈元素的左边宽度的累计。另外一个是当元素遍历完成后，栈中剩余元素的处理。这里一个非常巧妙的方法是在柱状图中末尾添加一个过度为0的柱子，这样当遍历到最后一个柱子时，可以将栈中所有元素弹出用于求解。

由于每个柱子都会有入栈和出栈的操作，因此算法的时间复杂度为O(n)。

```c++
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int res = 0;
        heights.push_back(0);  // 如果柱状图一直持续递增，若在数据集合中加入一个最小值，可以更新结果集合
        for (int height : heights) {
            int accumulativeWidth = 0;
            while ((!buffer_.empty()) && (buffer_.top().height >= height)) {
                accumulativeWidth += buffer_.top().width;  
                res = max(res, buffer_.top().height * accumulativeWidth);
                buffer_.pop();
            }

            buffer_.push({height, accumulativeWidth + 1});
        }

        return res;
    }

private:
    struct rect {
        int height;
        int width;
    };

    stack<rect> buffer_;
};
```

### 2、leetcode0042 接雨水（困难）

给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

解法：注意：需要继续深入思考一下累计宽度的含义。

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        int res = 0;
        for (auto val : height) {
            int accumulativeWidth = 0;
            while (!buffer_.empty() && buffer_.top().height <= val) {
                int bottom = buffer_.top().height;
                accumulativeWidth += buffer_.top().width;
                buffer_.pop();
                if (buffer_.empty()) {
                    break;
                }
                res += ((min(buffer_.top().height, val) - bottom) * accumulativeWidth);
            }
            buffer_.push({val, accumulativeWidth + 1});
        }
        return res;
    }

private:
    struct rect {
        int height;
        int width;
    };

    stack<rect> buffer_;
};
```

## 单调队列

## 哈希表

### 1、leetcode0001 双数之和（简单）

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。

解法1：在遍历数组前创建一个哈希表，该哈希表用于保存已经遍历过的数组的元素索引。当访问到数组的数据时，先将整数目标值和当前数据相减得出另外一个数据，查询该数据是否在哈希表中是否存在。若存在，则返回结果值。否则继续往哈希表中添加数据。

时间复杂度为O(n)，空间复杂度为O(n)

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        for (int i = 0; i < nums.size(); ++i) {
            const auto& it = buffer_.find(target - nums[i]);
            if (it != buffer_.cend()) {
                return {it->second, i};
            }
            buffer_.insert(make_pair(nums[i], i));
        }
        return {};
    }

private:
    unordered_map<int, int> buffer_;
};
```

### 2、leetcode0874 模拟行走机器人（中等）

机器人在一个无限大小的 XY 网格平面上行走，从点 (0, 0) 处开始出发，面向北方。该机器人可以接收以下三种类型的命令 commands ：

```
-2 ：向左转 90 度
-1 ：向右转 90 度
1 <= x <= 9 ：向前移动 x 个单位长度
```

在网格上有一些格子被视为障碍物 obstacles 。第 i 个障碍物位于网格点  obstacles[i] = (xi, yi) 。

机器人无法走到障碍物上，它将会停留在障碍物的前一个网格方块上，但仍然可以继续尝试进行该路线的其余部分。

返回从原点到机器人所有经过的路径点（坐标为整数）的最大欧式距离的平方。（即，如果距离为 5 ，则返回 25 ）

解法：关键为通过哈希表将障碍进行保存，若移动时发现下一处位置为障碍物，那么需要停止移动。

时间复杂度为O(m + n)，m为commands的长度，n为obstacles的长度

空间复杂度为O(n)，n为obstacles的长度

```c++
class Solution {
public:
    int robotSim(vector<int>& commands, vector<vector<int>>& obstacles) {
        // 初始化障碍物集合
        for (const auto& obstacle : obstacles) {
            obstacleGroup_.insert(calObstaclesHashVal(obstacle[0], obstacle[1]));
        }

        // 定义方向数组移动间距，用于二维平面的位置移动
        constexpr array<int, 4> xDir = {0, 1, 0, -1};
        constexpr array<int, 4> yDir = {1, 0, -1, 0};

        int res = 0;

        for (auto command : commands) {
            if (isRotateFlag(command)) {
                setMovedirection(command);
                continue;
            } 
            for (int i = 0; i < command; ++i) {
                int nextPosX = pos[0] + xDir[direction_];
                int nextPosY = pos[1] + yDir[direction_];
                uint32_t nextPosHash = calObstaclesHashVal(nextPosX, nextPosY);
                const auto& it = obstacleGroup_.find(nextPosHash);
                if (it != obstacleGroup_.end()) {
                    break;  // 如果下一个节点为障碍节点，则需要停止移动
                }
                pos[0] += xDir[direction_];
                pos[1] += yDir[direction_];
                res = max(res, pos[0] * pos[0] + pos[1] * pos[1]);
            }
        }

        return res;
    }

private:
    // 此处需要考虑数据溢出，需要将数据转换为无符号数据后再进行运算，否则在某些测试用例下会导致数据溢出
    uint32_t calObstaclesHashVal(int PosX, int PosY) {
        return static_cast<uint32_t>(PosY + 30000) * 60001u + static_cast<uint32_t>(PosX + 30000u); 
    }

    void setMovedirection(int command) {
        if (command == -1) {  // 向右转90度
            direction_ += 1;
        } else if (command == -2) {  // 向左转90度
            direction_ -= 1;
        }
        direction_ %= 4;
    }

    bool isRotateFlag(int command) {
        return (command == -1 || command == -2);
    }

private:
    set<uint32_t> obstacleGroup_;
    array<int, 2> pos = {0, 0};
    uint8_t direction_ = 0;
};
```

### 3、leetcode0049 字母异位词分组（中等）

给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。

解法1：遍历字符串数组时，将字符串进行排序，由于排序后的结果一致，可以将排序后的字符串作为key保存至哈希表中，当不同的字符串对应的key一致，那么其Wie字母异位词。

时间复杂度为O(nklogk)，n为strs的字符串数量，k为单个字符串的最大长度

空间复杂度为O(nk)，n为strs的字符串数量，k为单个字符串的最大长度

```c++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        string buffer = "";
        for (const auto& str : strs) {
            buffer.clear();
            buffer = str;
            sort(buffer.begin(), buffer.end());
            group_[buffer].push_back(str);
        }

        vector<vector<string>> res{};
        for (auto& val : group_) {
            res.emplace_back(std::move(val.second));
        }

        return res;
    }

private:
    unordered_map<string, vector<string>> group_;
};
```

## 递归

### 1、leetcode0078 子集（中等）

给你一个整数数组nums，数组中的元素互不相同。返回该数组所有可能的子集（幂集）。解集不能包含重复的子集。你可以按任意顺序 返回解集。

```
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

解法1：回溯法

本问题的本质就是找出满足要求的所有不重复的子集。对于子集查找，可以通过回溯获取所有子集。在本问题中，需要返回不同长度的子集，因此需要对数据长度进行遍历，依次求出满足数据长度的子集。

时间复杂度：

空间复杂度：

```c++
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        for (int size = 0; size <= nums.size(); ++size) {
            setSubsets(nums, size, 0);
        }
        return result;
    }

private:
    void setSubsets(vector<int>& nums, int size, int index) {
        if (subset.size() == size) {
            result.push_back(subset);
            return;
        }

        for (int i = index; i < nums.size(); ++i) {
            subset.push_back(nums[i]);
            setSubsets(nums, size, i + 1);
            subset.pop_back();
        }
    }

private:
    vector<vector<int>> result{};
    vector<int> subset{};
};
```

解法2：递归

对于数组中的每个整数，都存在选择或者不选择两种场景。遍历数组，每次都基于选择和不选择进行递归处理，那么就可以得出所有的不重复的子集。

时间复杂度：O(n * 2^n)

空间复杂度：

```c++
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        setSubsets(nums, 0);
        return result;
    }

private:
    void setSubsets(vector<int>& nums, int k) {
        if (nums.size() == k) {
            result.push_back(subset);
            return;
        }

        subset.push_back(nums[k]);
        setSubsets(nums, k + 1);  // 选择第k个整数
        subset.pop_back();
        setSubsets(nums, k + 1);  // 不选第k个整数
    }

private:
    vector<vector<int>> result{};
    vector<int> subset{};
};
```

### 2、leetcode0077 组合（中等）

给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。你可以按 任何顺序 返回答案。

```
输入：n = 4, k = 2
输出：
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

解法1：回溯

针对组合问题，可以通过回溯法遍历满足条件的解。

```c++
class Solution {
public:
    vector<vector<int>> combine(int n, int k) {
        setSubset(n, k, 1);
        return result;
    }

private:
    void setSubset(int n, int k, int index) {
        if (subset.size() == k) {
            result.push_back(subset);
            return;
        }

        for (int i = index; i <= n; ++i) {
            subset.push_back(i);
            setSubset(n, k, i + 1);
            subset.pop_back();
        }
    }

private:
    vector<vector<int>> result{};
    vector<int> subset{};
};
```

## 二叉树

### 1、leetcode0226 翻转二叉树（简单）

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

时间复杂度O(n)，n为二叉树节点的树木

空间复杂度O(n)，主要由递归栈的深度决定

```c++
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == nullptr) {
            return nullptr;
        }

        swap(root->left, root->right);  // 先处理本层
        (void)invertTree(root->left);  // 左子树递归
        (void)invertTree(root->right);  // 右子树递归

        return root;
    }
};
```

```c++
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == nullptr) {
            return nullptr;
        }

        TreeNode* left = invertTree(root->left);  // 左子树递归
        TreeNode* right = invertTree(root->right);  // 右子树递归
        root->left = right;  // 本层处理
        root->right = left;  // 本层处理

        return root;
    }
};
```













































































