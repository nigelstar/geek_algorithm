# 数组

### 1、leetcode0088 合并两个有序数组 (简单)

给你两个按 非递减顺序排列的整数数组nums1和nums2，另有两个整数m和n，分别表示nums1和nums2中的元素数目。请你合并nums2到nums1中，使合并后的数组同样按非递减顺序排列。

注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。

解法1：归并

此题考察了归并排序中的归并处理，通过一个缓存空间buffer保存nums1，然后按照归并处理将buffer和nums2的合并结果保存至nums1中。

时间复杂度为O(m + n)，空间复杂度也为O(m + n)

```c++
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        vector<int> buffer = nums1;
        int left = 0;
        int right = 0;
        for (int i = 0; i < nums1.size(); ++i) {
            if (right >= n || (left < m && buffer[left] <= nums2[right])) {
                nums1[i] = buffer[left++];
            } else {
                nums1[i] = nums2[right++];
            }
        }
    }
};
```

解法2：数组从尾到前遍历

时间复杂度为O(m + n)，空间复杂度也为O(1)

```c++
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int x = m - 1;
        int y = n - 1;
        for (int i = m + n - 1; i >= 0; --i) {
            if (y < 0 || (x >= 0 && nums1[x] >= nums2[y])) {
                nums1[i] = nums1[x--];
            } else {
                nums1[i] = nums2[y--];
            }
        }
    }
};
```

### 2、leetcode0066 加一 (简单)

给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。你可以假设除了整数 0 之外，这个整数不会以零开头。

解法：对于整数加1，主要是要考虑进位。解题步骤如下：

1. 将最后一位整数和1进行相加，分别得到最后一位的结果和进位值；
2. 从数组的倒数第二位开始往前遍历数组，将整数分别和进位值相加，如果进位值为0，则停止遍历返回结果。
3. 遍历结束后，如果进位值为0，直接返回结果，如果进位值为1，则在数组开头加入1后返回结果。

```c++
class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
        int result = digits.back() + 1;
        digits.back() = result % 10;
        int carry = result / 10;
        
        for (int i = static_cast<int>(digits.size()) - 2; i >= 0; --i) {
            if (carry == 0) {
                return digits;
            }
            result = digits[i] + carry;
            digits[i] = result % 10;
            carry = result / 10;
        }

        if (carry == 0) {
            return digits;
        }

        digits.insert(digits.begin(), 1);

        return digits;
    }
};
```

看到其他更好的解题思路，由于最后一位加1和进位加1的效果一致，那么可以直接在数组中从后往前进行遍历。解题思路如下：

1. 从后往前遍历数组，将每个整数与1相加，将相加后的结果与10进行求余，如果求余后的值不为0，则直接返回结果，否则继续遍历；
2. 当遍历结束后，如果数组首位的结果为0，那么需要在数组头部加入一个整数1，否则直接返回结果。

```c++
class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
        for (int i = digits.size() - 1; i >= 0; --i) {
            ++digits[i];  // 个数位加1或者进位加1
            digits[i] %= 10;
            if (digits[i] != 0) {
                return digits;
            }
        }
        if (digits.front() == 0) {
            digits.insert(digits.begin(), 1);
        }
        return digits;
    }
};
```

# 链表

### 1、leetcode0206 反转链表 (简单)

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

解法1：迭代

```c++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* pre = nullptr;
        while (head != nullptr) {
            ListNode* next = head->next;
            head->next = pre;
            pre = head;
            head = next;
        }
        return pre;
    }
};
```

解法2：递归

```c
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (head == nullptr || head->next == nullptr) {
            return head;
        }

        ListNode* res = reverseList(head->next);
        head->next->next = head;
        head->next = nullptr;

        return res;
    }
};
```

### 2、leetcode0025 K 个一组翻转链表（困难）

给你链表的头节点head，每 k 个节点一组进行翻转，请你返回修改后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。

解法：

在本题中按照K个一组对链表进行翻转，那么首先需要按序找到一组K个链表节点，然后这组链表节点进行翻转，最后将不同组的结果进行合并。代码如下：

```c++
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        // 设置头部哑结点，处理归一
        ListNode* dummy = new ListNode(0, head);
        ListNode* prev = dummy;

        while (head != nullptr) {
            // 1. 按照k个节点进行分组
            ListNode* tail = getTailNodeInGroup(head, k);
            if (tail == nullptr) {
                break;  // 若尾部的节点个数小于k个，退出循环
            }

            ListNode* nextGroupHead = tail->next;  // 先获取下一组待处理的头节点
            reverseNodeInGroup(head, nextGroupHead);  // 2. 反转本组的k个节点

            // 3. 更新每组和前一组、后一组的节点关系
            head->next = nextGroupHead;  // 和后一组创建关系
            prev->next = tail;  // 和前一组创建关系

            prev = head;  // 重置prev节点
            head = nextGroupHead;  // 重置head节点
        }

        ListNode* res = dummy->next;
        delete dummy;  
        
        return res;
    }

    ListNode* getTailNodeInGroup(ListNode* head, int k) {
        while (head != nullptr) {
            --k;
            if (k == 0) {
                return head;
            }
            head = head->next;
        }

        return nullptr;
    }

    void reverseNodeInGroup(ListNode* head, ListNode* stop) {
        ListNode* prev = head;
        head = head->next;
        while (head != stop) {
            ListNode* next = head->next;
            head->next = prev;
            prev = head;
            head = next;
        }
    }
};
```

### 3、leetcode0021 合并两个有序链表（简单）

将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

解法1：迭代

```c++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode* dummy = new ListNode();
        ListNode* result = dummy;
        while ((list1 != nullptr) || (list2 != nullptr)) {
            if (list2 == nullptr || (list1 != nullptr && list1->val <= list2->val)) {
                dummy->next = list1;
                list1 = list1->next;
            } else {
                dummy->next = list2;
                list2 = list2->next;
            }
            dummy = dummy->next;
        }

        return result->next;
    }
};
```

解法2：递归

```c++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        if (list1 == nullptr) {
            return list2;
        }

        if (list2 == nullptr) {
            return list1;
        }

        if (list1->val <= list2->val) {
            list1->next = mergeTwoLists(list1->next, list2);
            return list1;
        }

        list2->next = mergeTwoLists(list1, list2->next);
        return list2;
    }
};
```

### 4、acw0136 邻值查找

给定一个长度为 n 的序列 A，A 中的数各不相同。对于 A 中的每一个数 A~i~，求：min~1≤j<i~|A~i~−A~j~|以及令上式取到最小值的 j（记为 P~i~）。若最小值点不唯一，则选择使 A~j~ 较小的那个。

```c++
#include <iostream>
#include <algorithm>

using namespace std;

struct Node {
    Node() : Node(0, 0) {}
    Node(int val, int index) : val(val), index(index), prev(nullptr), next(nullptr) {}
    int val = 0;
    int index = 0;
    Node* prev = nullptr;
    Node* next = nullptr;
};

Node* addNode(Node* cur, int val, int index) {
    Node* node = new Node(val, index);
    node->next = cur->next;
    cur->next->prev = node;
    cur->next = node;
    node->prev = cur;
    return node;
}

void deleteNode(Node* node) {
    node->prev->next = node->next;
    node->next->prev = node->prev;
    delete node;
}

int main() {
    int cnt = 0;
    cin >> cnt;
    int* data = new int[cnt];
    int* rk = new int[cnt]; // rk的含义为表示第i名的是哪个下标
    for (int i = 0; i < cnt; ++i) {
        cin >> data[i];
        rk[i] = i;
    }
    
    sort(rk, rk + cnt, [&](int lhs, int rhs) { 
        return data[lhs] < data[rhs]; 
    });  // 在rk数组中，根据data索引指向的值从小到大保存索引值
    
    Node* head = new Node(data[rk[0]] - 1e9, 0);
    Node* tail = new Node(data[rk[cnt - 1]] + 1e9, 0);
    head->next = tail;
    tail->prev = head;
    Node** pos = new Node*[cnt]();
    for (int i = 0; i < cnt; ++i) {
        // 按照从小到大顺序添加节点，链表为有序链表，并且将节点指针保存起来，pos是乱序的，和data完全对应
        pos[rk[i]] = addNode(tail->prev, data[rk[i]], rk[i]);
    }
    
    int* ans = new int[cnt];
    for (int i = cnt - 1; i >= 0; --i) {
        // 从后往前去查找结果，因为是判断1≤j<i的范围内的最小值
        Node* node = pos[i];
        if (data[i] - node->prev->val <= node->next->val - data[i]) {
            ans[i] = node->prev->index;
        } else {
            ans[i] = node->next->index;
        }
        deleteNode(node);  // 查询完结构需要删除掉节点
    }
    
    for (int i = 1; i < cnt; ++i) {
        // 注意索引输出需要加1，与案例的值保持一致
        cout << abs(data[ans[i]] - data[i]) << " " << ans[i] + 1 << endl;
    }
    
    return 0;
}
```

# 栈

### 1、leetcode0020 有效的括号（简单）

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。有效字符串需满足：

左括号必须用相同类型的右括号闭合。

左括号必须以正确的顺序闭合。

每个右括号都有一个对应的相同类型的左括号。

解法1：通过栈保存左括号，并通过“最近相关性”来判断最近的左括号与右括号是否匹配。代码如下：

```c++
class Solution {
public:
    bool isValid(string s) {
        stack<char> buffer{};
        for (auto c : s) {
            if (c == '(' || c == '{' || c == '[') {
                buffer.push(c);
            } else {
                if (buffer.empty()) {
                    return false;
                }
                if (c == ')' && buffer.top() != '(') {
                    return false;
                }
                if (c == '}' && buffer.top() != '{') {
                    return false;
                }
                if (c == ']' && buffer.top() != '[') {
                    return false;
                }
                buffer.pop();
            }
        }
        return buffer.empty();
    }
};
```

### 2、leetcode0155 最小栈（中等）

设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。实现 MinStack 类:

MinStack() 初始化堆栈对象。
void push(int val) 将元素val推入堆栈。
void pop() 删除堆栈顶部的元素。
int top() 获取堆栈顶部的元素。
int getMin() 获取堆栈中的最小元素。

解法：本题的关键点是如何保存最小元素，并且要在常数时间内检索到最小元素。因此，需要通过另外一个栈辅助保存最小元素。

```c++
class MinStack {
public:
    MinStack() {}
    
    void push(int val) {
        data_buffer_.push(val);
        if (min_buffer_.empty()) {
            min_buffer_.push(val);
        } else {
            min_buffer_.push(min(min_buffer_.top(), val));
        }
    }
    
    void pop() {
        data_buffer_.pop();
        min_buffer_.pop();
    }
    
    int top() {
        return data_buffer_.top();
    }
    
    int getMin() {
        return min_buffer_.top();
    }

private:
    stack<int> data_buffer_;  // 保存插入数据
    stack<int> min_buffer_;  // 保存最小元素，并且和data_buffer_保持一一对应的关系
};
```

### 3、leetcode0150 逆波兰表达式求值（中等）

根据 逆波兰表示法，求表达式的值。有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。注意：两个整数之间的除法只保留整数部分。

可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。

解法：

当扫描到运算符时，需要获取最近的两个数，那么比较适合通过栈来保存数据。如果遇到数，则将其压入到栈。如果遇到运算符，则取出栈顶的两个数进行计算，然后把结果压入栈。时间复杂度为O(n)

```c++
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<int> buffer{};
        for (const auto& str : tokens) {
            if (isOperator(str)) {
                int y = buffer.top();
                buffer.pop();
                int x = buffer.top();
                buffer.pop();
                buffer.push(calculate(x, y, str));
            } else {
                buffer.push(stoi(str));
            }
        }
        return buffer.top();
    }

    bool isOperator(const string& str) const {
        return (str == "+") || (str == "-") || (str == "*") || (str == "/");
    }

    long calculate(int x, int y, const string& oper) {
        if (oper == "+") {
            return x + y;
        }
        if (oper == "-") {
            return x - y;
        }
        if (oper == "*") {
            return static_cast<long>(x) * y;  // 注意需要转换整数的长度，避免两个数相乘后超过最大值
        }
        return x / y;
    }
};
```

## 队列

### 1、leetcode0641 设计循环双端队列（中等）

设计实现双端队列。实现 MyCircularDeque 类:

```
MyCircularDeque(int k) ：构造函数,双端队列最大为 k 。
boolean insertFront()：将一个元素添加到双端队列头部。 如果操作成功返回 true ，否则返回 false 。
boolean insertLast() ：将一个元素添加到双端队列尾部。如果操作成功返回 true ，否则返回 false 。
boolean deleteFront() ：从双端队列头部删除一个元素。 如果操作成功返回 true ，否则返回 false 。
boolean deleteLast() ：从双端队列尾部删除一个元素。如果操作成功返回 true ，否则返回 false 。
int getFront() )：从双端队列头部获得一个元素。如果双端队列为空，返回 -1 。
int getRear() ：获得双端队列的最后一个元素。 如果双端队列为空，返回 -1 。
boolean isEmpty() ：若双端队列为空，则返回 true ，否则返回 false  。
boolean isFull() ：若双端队列满了，则返回 true ，否则返回 false 。
```

解法1：由于本题中k的取值范围为[1, 1000]，值的范围不大，可通过数组实现双端队列。代码如下：

```c++
class MyCircularDeque {
private:
    vector<int> buffer_;
    int start_;
    int end_;

public:
    MyCircularDeque(int k) {
        buffer_ = vector(k + 1, 0);
        start_ = 0;
        end_ = 0;
    }
    
    bool insertFront(int value) {
        if (isFull()) {
            return false;
        }

        start_ = (start_ == 0) ? (buffer_.size() - 1) : (start_ - 1);
        buffer_[start_] = value;

        return true;
    }
    
    bool insertLast(int value) {
        if (isFull()) {
            return false;
        }

        buffer_[end_] = value;
        end_ = (end_ + 1) % buffer_.size();

        return true;
    }
    
    bool deleteFront() {
        if (isEmpty()) {
            return false;
        }

        start_ = (start_ + 1) % buffer_.size();

        return true;
    }
    
    bool deleteLast() {
        if (isEmpty()) {
            return false;
        }

        end_ = (end_ == 0) ? (buffer_.size() - 1) : (end_ - 1);

        return true;
    }
    
    int getFront() {
        return isEmpty() ? -1 : buffer_[start_];
    }
    
    int getRear() {
        if (isEmpty()) {
            return -1;
        }

        int index = (end_ == 0) ? (buffer_.size() - 1) : (end_ - 1);
        return buffer_[index];
    }
    
    bool isEmpty() {
        return (start_ == end_);
    }
    
    bool isFull() {
        return ((end_ + 1) % buffer_.size() == start_);
    }
};
```

# 单调栈

### 1、leetcode0084 柱状图中最大的矩形（困难）

给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。

解法1：暴力求解

针对每一个柱子，分别向左和向右找到最后一个高于等于该柱子高度的柱子作为边界，这样就为该柱子对应的最大矩形。但是该算法的时间复杂度为O(n^2)，如果柱状图中所有的柱子高度相等，那么算法执行会超时。

解法2：单调栈

如果柱状图一直递增，那么每个柱子对应的最大矩形只能向右找。若维护一个单调栈，栈内所保存的柱子的高度是单调递减的，当处理的柱子高度低于栈顶的柱子高度时，那么可求出栈顶柱子的最大矩形面积。

在这中间需要注意两个点，一个是宽度的累积，由于栈顶的柱子高度值最大，那么其可用于非栈顶元素的最大矩形求解，同时也用于待入栈元素的左边宽度的累计。另外一个是当元素遍历完成后，栈中剩余元素的处理。这里一个非常巧妙的方法是在柱状图中末尾添加一个过度为0的柱子，这样当遍历到最后一个柱子时，可以将栈中所有元素弹出用于求解。

由于每个柱子都会有入栈和出栈的操作，因此算法的时间复杂度为O(n)。

```c++
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int res = 0;
        heights.push_back(0);  // 如果柱状图一直持续递增，若在数据集合中加入一个最小值，可以更新结果集合
        for (int height : heights) {
            int accumulativeWidth = 0;
            while ((!buffer_.empty()) && (buffer_.top().height >= height)) {
                accumulativeWidth += buffer_.top().width;  
                res = max(res, buffer_.top().height * accumulativeWidth);
                buffer_.pop();
            }

            buffer_.push({height, accumulativeWidth + 1});
        }

        return res;
    }

private:
    struct rect {
        int height;
        int width;
    };

    stack<rect> buffer_;
};
```

### 2、leetcode0042 接雨水（困难）

给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

解法：注意：需要继续深入思考一下累计宽度的含义。

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        int res = 0;
        for (auto val : height) {
            int accumulativeWidth = 0;
            while (!buffer_.empty() && buffer_.top().height <= val) {
                int bottom = buffer_.top().height;
                accumulativeWidth += buffer_.top().width;
                buffer_.pop();
                if (buffer_.empty()) {
                    break;
                }
                res += ((min(buffer_.top().height, val) - bottom) * accumulativeWidth);
            }
            buffer_.push({val, accumulativeWidth + 1});
        }
        return res;
    }

private:
    struct rect {
        int height;
        int width;
    };

    stack<rect> buffer_;
};
```

# 单调队列

## 实践

### 1、leetcode0239 滑动窗口最大值（困难）

给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。返回滑动窗口中的最大值 。

注意点：

- 1 <= nums.length <= 10^5^
- -10^4^ <= nums[i] <= 10^4^
- 1 <= k <= nums.length

解法1：针对滑动窗口，通过双端队列维护一个单调递减的队列，在队列中保存数据的索引值。

在每次遍历数据时，先判断是否需要出栈，出栈的条件是队首的元素已经不在滑动窗口中，此时需要出栈。

接着往单调队列中添加数据，若队尾的数据不大于当前数据，则需要从队尾出队，从而维护单调递减的队列。

最后，当数据遍历到第一个滑动窗口尾部时，将队首元素保存至结果集合中。

```c++
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        vector<int> result(nums.size() - k + 1);  // 预先分配好vector的内存空间，避免后续内存扩展
        for (int i = 0; i < nums.size(); ++i) {
            // 出队操作
            if (!window_.empty() && (i - window_.front() == k)) {
                window_.pop_front();
            }

            // 入队操作
            while (!window_.empty() && (nums[window_.back()] <= nums[i])) {
                window_.pop_back();
            }
            window_.push_back(i);

            // 更新结果
            int index = i - k + 1;
            if (index >= 0) {
                result[index] = nums[window_.front()];
            }
        }
        return result;
    }

private:
    deque<int> window_;  // 通过一个队列保存一个单调递减的队列
};
```

# 哈希表

## 理论

### 1、如何设计一个哈希表？？？

## 实践

### 1、leetcode0001 双数之和（简单）

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。

解法1：在遍历数组前创建一个哈希表，该哈希表用于保存已经遍历过的数组的元素索引。当访问到数组的数据时，先将整数目标值和当前数据相减得出另外一个数据，查询该数据是否在哈希表中是否存在。若存在，则返回结果值。否则继续往哈希表中添加数据。

时间复杂度为O(n)，空间复杂度为O(n)

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        for (int i = 0; i < nums.size(); ++i) {
            const auto& it = buffer_.find(target - nums[i]);
            if (it != buffer_.cend()) {
                return {it->second, i};
            }
            buffer_.insert(make_pair(nums[i], i));
        }
        return {};
    }

private:
    unordered_map<int, int> buffer_;
};
```

### 2、leetcode0874 模拟行走机器人（中等）

机器人在一个无限大小的 XY 网格平面上行走，从点 (0, 0) 处开始出发，面向北方。该机器人可以接收以下三种类型的命令 commands ：

```
-2 ：向左转 90 度
-1 ：向右转 90 度
1 <= x <= 9 ：向前移动 x 个单位长度
```

在网格上有一些格子被视为障碍物 obstacles 。第 i 个障碍物位于网格点  obstacles[i] = (xi, yi) 。

机器人无法走到障碍物上，它将会停留在障碍物的前一个网格方块上，但仍然可以继续尝试进行该路线的其余部分。

返回从原点到机器人所有经过的路径点（坐标为整数）的最大欧式距离的平方。（即，如果距离为 5 ，则返回 25 ）

解法：关键为通过哈希表将障碍进行保存，若移动时发现下一处位置为障碍物，那么需要停止移动。

时间复杂度为O(m + n)，m为commands的长度，n为obstacles的长度

空间复杂度为O(n)，n为obstacles的长度

```c++
class Solution {
public:
    int robotSim(vector<int>& commands, vector<vector<int>>& obstacles) {
        // 初始化障碍物集合
        for (const auto& obstacle : obstacles) {
            obstacleGroup_.insert(calObstaclesHashVal(obstacle[0], obstacle[1]));
        }

        // 定义方向数组移动间距，用于二维平面的位置移动
        constexpr array<int, 4> xDir = {0, 1, 0, -1};
        constexpr array<int, 4> yDir = {1, 0, -1, 0};

        int res = 0;

        for (auto command : commands) {
            if (isRotateFlag(command)) {
                setMovedirection(command);
                continue;
            } 
            for (int i = 0; i < command; ++i) {
                int nextPosX = pos[0] + xDir[direction_];
                int nextPosY = pos[1] + yDir[direction_];
                uint32_t nextPosHash = calObstaclesHashVal(nextPosX, nextPosY);
                const auto& it = obstacleGroup_.find(nextPosHash);
                if (it != obstacleGroup_.end()) {
                    break;  // 如果下一个节点为障碍节点，则需要停止移动
                }
                pos[0] += xDir[direction_];
                pos[1] += yDir[direction_];
                res = max(res, pos[0] * pos[0] + pos[1] * pos[1]);
            }
        }

        return res;
    }

private:
    // 此处需要考虑数据溢出，需要将数据转换为无符号数据后再进行运算，否则在某些测试用例下会导致数据溢出
    uint32_t calObstaclesHashVal(int PosX, int PosY) {
        return static_cast<uint32_t>(PosY + 30000) * 60001u + static_cast<uint32_t>(PosX + 30000u); 
    }

    void setMovedirection(int command) {
        if (command == -1) {  // 向右转90度
            direction_ += 1;
        } else if (command == -2) {  // 向左转90度
            direction_ -= 1;
        }
        direction_ %= 4;
    }

    bool isRotateFlag(int command) {
        return (command == -1 || command == -2);
    }

private:
    set<uint32_t> obstacleGroup_;
    array<int, 2> pos = {0, 0};
    uint8_t direction_ = 0;
};
```

### 3、leetcode0049 字母异位词分组（中等）

给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。

解法1：遍历字符串数组时，将字符串进行排序，由于排序后的结果一致，可以将排序后的字符串作为key保存至哈希表中，当不同的字符串对应的key一致，那么其Wie字母异位词。

时间复杂度为O(nklogk)，n为strs的字符串数量，k为单个字符串的最大长度

空间复杂度为O(nk)，n为strs的字符串数量，k为单个字符串的最大长度

```c++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        string buffer = "";
        for (const auto& str : strs) {
            buffer.clear();
            buffer = str;
            sort(buffer.begin(), buffer.end());  // 排序处理，时间复杂度为nlogn，n为字符串的长度
            group_[buffer].push_back(str);
        }

        vector<vector<string>> res{};
        for (auto& val : group_) {
            res.emplace_back(std::move(val.second));
        }

        return res;
    }

private:
    unordered_map<string, vector<string>> group_;
};
```

### 4、leetcode0030 串联所有单词的子串（困难）

给定一个字符串s和一个字符串数组words。 words中所有字符串长度相同。s中的串联子串是指一个包含words中所有字符串以任意顺序排列连接起来的子串。

例如，如果 words = ["ab","cd","ef"]， 那么 "abcdef"， "abefcd"，"cdabef"， "cdefab"，"efabcd"， 和 "efcdab" 都是串联子串。 "acdbef" 不是串联子串，因为他不是任何 words 排列的连接。返回所有串联字串在 s 中的开始索引。你可以以 任意顺序 返回答案。

```
1 <= s.length <= 104
1 <= words.length <= 5000
1 <= words[i].length <= 30
words[i] 和 s 由小写英文字母组成
```

解法1：

由于串联子串是指一个包含words中所有字符串以任意顺序排列连接起来的子串，且words中所有字符串的长度相同，那么串联子串的长度是一个固定值。通过该长度可以将字符串进行分割成多个字符串。将字符串数组words中的所有字符串保存至哈希表中，其中key为字符串，val为pair<int, int>，pair对的first保存word出现的次数，pair对的second用于校验子串是否满足条件。

继续将分割的字符串按照字符串数组words中的任何一个字符串的长度进行分割，针对每个子字符串，首先从前面保存的哈希表中查询是否存在，如果不存在则可以直接返回，否则将pair对的second进行减1操作。当操作完成后，如果哈希表中所有节点的pair对的second都为0，那么满足条件。

```c++
class Solution {
public:
    vector<int> findSubstring(string s, vector<string>&将) {
        // 将字符串数组words缓存为哈希表
        for (const auto& word : words) {
            ++(wordsBuffer_[word].first);
        }

        int wordLen = words.front().length();  // 获取单个字符串长度，用于后期分割子串
        int subLen = wordLen * words.size();  // 获取子串的长度
        vector<int> result{};

        for (int i = 0; i + subLen <= s.length(); ++i) {
            if (validSubStr(s.substr(i, subLen), wordLen)) {
                result.push_back(i);
            }
        }

        return result;
    }

    bool validSubStr(const string& s, int wordLen) {
        // 将wordsBuffer_中的数据的pair的second进行重置
        for (auto& it : wordsBuffer_) {
            it.second.second = it.second.first;
        }

        for (int i = 0; i < s.length(); i += wordLen) {
            auto it = wordsBuffer_.find(s.substr(i, wordLen));
            if (it == wordsBuffer_.end()) {
                return false;  // 剪枝处理，如果wordsBuffer_中不存在该键值对，直接返回false
            }
            --(it->second.second);  // 对second进行自减操作
        }

        for (const auto& it : wordsBuffer_) {
            if (it.second.second != 0) {
                return false;  // 若键值对中的second的不等于，此时可以直接返回false
            }
        }

        return true;  // 当所有条件都满足后，返回true
    }

private:
    unordered_map<string, pair<int, int>> wordsBuffer_{};
};
```

### 5、leetcode0146 LRU 缓存（中等）

请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。实现 LRUCache 类：

LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存

int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。

void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该逐出最久未使用的关键字。

**函数 get 和 put 必须以 O(1) 的平均时间复杂度运行**。

注意点：

- 1 <= capacity <= 3000
- 0 <= key <= 10000
- 0 <= value <= 10^5^
- 最多调用 2 * 10^5^ 次 get 和 put

解法1：链表 + 哈希表

LRU为Least Recently Used的缩写，即需要保存最近操作的数据，同时当超过容量限制时，淘汰掉最旧数据。为了维持数据的时效性，可以通过一个链表保存数据，当数据被操作后，需要移动至链表头部，表示该数据最近被访问。

```c++
class LRUCache {
public:
    LRUCache(int capacity) : capacity_(capacity) {
        dummyHead_ = make_unique<Node>();
        dummyTail_ = make_unique<Node>();
        dummyHead_->next = dummyTail_.get();
        dummyTail_->prev = dummyHead_.get();
    }
    
    int get(int key) {
        const auto& it = buffer_.find(key);
        if (it == buffer_.cend()) {
            return -1;
        }

        remove(it->second.get());
        insert(it->second.get());

        return it->second->value;
    }
    
    void put(int key, int value) {
        auto it = buffer_.find(key);
        if (it == buffer_.cend()) {
            insert(key, value);
            if (buffer_.size() > capacity_) {
                Node* tail = dummyTail_->prev;
                remove(tail);
                buffer_.erase(tail->key);
            } 
        } else {
            remove(it->second.get());
            insert(it->second.get());
            it->second->value = value;
        }
    }

private:
    struct Node {
        Node() : Node(0, 0) {}
        Node(int key, int value) : key(key), value(value), prev(nullptr), next(nullptr) {}
        int key;
        int value;
        Node* prev;
        Node* next;
    };

    void remove(Node* node) {
        assert(node != nullptr);
        node->next->prev = node->prev;
        node->prev->next = node->next;
    }

    void insert(int key, int value) {
        auto node = make_unique<Node>(key, value);
        insert(node.get());
        buffer_[key] = std::move(node);
    }

    void insert(Node* node) {
        node->next = dummyHead_->next;
        dummyHead_->next = node;
        node->prev = node->next->prev;
        node->next->prev = node;
    }

    unique_ptr<Node> dummyHead_;
    unique_ptr<Node> dummyTail_;
    int capacity_;
    unordered_map<int, unique_ptr<Node>> buffer_;
};
```

### 6、leetcode0811 子域名访问计数

网站域名 "discuss.leetcode.com" 由多个子域名组成。顶级域名为 "com" ，二级域名为 "leetcode.com" ，最低一级为 "discuss.leetcode.com" 。当访问域名 "discuss.leetcode.com" 时，同时也会隐式访问其父域名 "leetcode.com" 以及 "com" 。

计数配对域名 是遵循 "rep d1.d2.d3" 或 "rep d1.d2" 格式的一个域名表示，其中 rep 表示访问域名的次数，d1.d2.d3 为域名本身。

例如，"9001 discuss.leetcode.com" 就是一个 计数配对域名 ，表示 discuss.leetcode.com 被访问了 9001 次。
给你一个 计数配对域名 组成的数组 cpdomains ，解析得到输入中每个子域名对应的 计数配对域名 ，并以数组形式返回。可以按 任意顺序 返回答案。

 解法1：哈希+string分解

```c++
class Solution {
public:
    vector<string> subdomainVisits(vector<string>& cpdomains) {
        for (const auto& cpdomain : cpdomains) {
            int index = 0;
            while (cpdomain[index] != ' ') {
                ++index;
            }
            int cnt = stoi(cpdomain.substr(0, index));

            buffer_[cpdomain.substr(index + 1, cpdomain.length() - index - 1)] += cnt;
            for (int i = index + 1; i < cpdomain.length(); ++i) {
                if (cpdomain[i] == '.') {
                    buffer_[cpdomain.substr(i + 1, cpdomain.length() - i - 1)] += cnt;
                }
            }
        }

        vector<string> ans{};
        for (const auto& it : buffer_) {
            ans.emplace_back(to_string(it.second) + " " + it.first);
        }
        return ans;
    }

private:
    unordered_map<string, int> buffer_;
};
```

### 7、leetcode0697 数组的度

给定一个非空且只包含非负数的整数数组 nums，数组的 度 的定义是指数组里任一元素出现频数的最大值。

你的任务是在 nums 中找到与 nums 拥有相同大小的度的最短连续子数组，返回其长度。

解法1：哈希表

```c++
class Solution {
public:
    int findShortestSubArray(vector<int>& nums) {
        unordered_map<int, pair<uint16_t, pair<int, int>>> buffer{};
        for (int i = 0; i < nums.size(); ++i) {
            auto it = buffer.find(nums[i]);
            if (it == buffer.end()) {
                buffer[nums[i]] = {1, {i, i}};
            } else {
                ++(it->second.first);
                it->second.second.second = i;
            }
        }

        uint16_t maxCnt = 0;
        for (const auto& it : buffer) {
            maxCnt = max(maxCnt, it.second.first);
        }

        int ans = numeric_limits<int>::max();
        for (const auto& it : buffer) {
            if (it.second.first == maxCnt) {
                ans = min(ans, it.second.second.second - it.second.second.first + 1);
            }
        }

        return ans;
    }
};
```

# 递归

### 1、leetcode0078 子集（中等）

```
给你一个整数数组nums，数组中的元素互不相同。返回该数组所有可能的子集（幂集）。解集不能包含重复的子集。你可以按任意顺序 返回解集。

输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

解法1：回溯法

本问题的本质就是找出满足要求的所有不重复的子集。对于子集查找，可以通过回溯获取所有子集。在本问题中，需要返回不同长度的子集，因此需要对数据长度进行遍历，依次求出满足数据长度的子集。

时间复杂度：

空间复杂度：

```c++
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        for (int size = 0; size <= nums.size(); ++size) {
            setSubsets(nums, size, 0);
        }
        return result;
    }

private:
    void setSubsets(vector<int>& nums, int size, int index) {
        if (subset.size() == size) {
            result.push_back(subset);
            return;
        }

        for (int i = index; i < nums.size(); ++i) {
            subset.push_back(nums[i]);
            setSubsets(nums, size, i + 1);
            subset.pop_back();
        }
    }

private:
    vector<vector<int>> result{};
    vector<int> subset{};
};
```

解法2：递归

对于数组中的每个整数，都存在选择或者不选择两种场景。遍历数组，每次都基于选择和不选择进行递归处理，那么就可以得出所有的不重复的子集。

时间复杂度：O(n * 2^n)

空间复杂度：

```c++
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        setSubsets(nums, 0);
        return result;
    }

private:
    void setSubsets(vector<int>& nums, int k) {
        if (nums.size() == k) {
            result.push_back(subset);
            return;
        }

        subset.push_back(nums[k]);
        setSubsets(nums, k + 1);  // 选择第k个整数
        subset.pop_back();
        setSubsets(nums, k + 1);  // 不选第k个整数
    }

private:
    vector<vector<int>> result{};
    vector<int> subset{};
};
```

### 2、leetcode0077 组合（中等）

给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。你可以按 任何顺序 返回答案。

```
输入：n = 4, k = 2
输出：
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

解法1：回溯

针对组合问题，可以通过回溯法遍历满足条件的解。

```c++
class Solution {
public:
    vector<vector<int>> combine(int n, int k) {
        setSubset(n, k, 1);
        return result;
    }

private:
    void setSubset(int n, int k, int index) {
        if (subset.size() == k) {
            result.push_back(subset);
            return;
        }

        for (int i = index; i <= n; ++i) {
            subset.push_back(i);
            setSubset(n, k, i + 1);
            subset.pop_back();
        }
    }

private:
    vector<vector<int>> result{};
    vector<int> subset{};
};
```

### 3、leetcode0046 全排列

给定一个不含重复数字的数组 `nums` ，返回其 所有可能的全排列。你可以 **按任意顺序** 返回答案。

解法1：针对全排列问题，每次都需要遍历数组的所有数据，但是需要通过一些非局部变量保存一些状态数据，避免重复访问数据。

 ```c++
 class Solution {
 public:
     vector<vector<int>> permute(vector<int>& nums) {
         usedFlag_ = vector<bool>(nums.size(), false);
         recur(nums);
         return ans_;
     }
 
 private:
     void recur(vector<int>& nums) {
         if (nums.size() == subset_.size()) {
             ans_.push_back(subset_);
             return;
         }
 
         for (int i = 0; i < nums.size(); ++i) {
             if (!usedFlag_[i]) {
                 usedFlag_[i] = true;
                 subset_.push_back(nums[i]);
                 recur(nums);
                 subset_.pop_back();
                 usedFlag_[i] = false;
             }
         }
     }
 
 private:
     vector<vector<int>> ans_;
     vector<int> subset_;
     vector<bool> usedFlag_;
 };
 ```



# 二叉树

### 1、leetcode0226 翻转二叉树（简单）

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

时间复杂度O(n)，n为二叉树节点的个数

空间复杂度O(n)，主要由递归栈的深度决定

```c++
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == nullptr) {
            return nullptr;
        }

        swap(root->left, root->right);  // 先处理本层
        (void)invertTree(root->left);  // 左子树递归
        (void)invertTree(root->right);  // 右子树递归

        return root;
    }
};
```

```c++
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == nullptr) {
            return nullptr;
        }

        TreeNode* left = invertTree(root->left);  // 左子树递归
        TreeNode* right = invertTree(root->right);  // 右子树递归
        root->left = right;  // 本层处理
        root->right = left;  // 本层处理

        return root;
    }
};
```

### 2、leetcode0098 验证二叉搜索树（中等）

给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。

有效二叉搜索树定义如下：

节点的左子树只包含 小于 当前节点的数。

节点的右子树只包含 大于 当前节点的数。

所有左子树和右子树自身必须也是二叉搜索树。

解法1：该题的关键是**左子树的所有节点都小于根节点，右子树的所有节点都大于根节点**。针对每个节点（除开根节点），其值必然在某个具体的范围内，那么只需要判断该节点的值是否在范围内即可。

时间复杂度O(n)，n为二叉树节点的个数

空间复杂度O(n)，主要由递归栈的深度决定

```c++
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        return isValidBST(root, nullptr, nullptr);
    }

private:
    bool isValidBST(TreeNode* root, int* min, int* max) {
        if (root == nullptr) {
            return true;
        }

        if ((min != nullptr) && (root->val <= *min)) {
            return false;
        }

        if ((max != nullptr) && (root->val >= *max)) {
            return false;
        }

        return isValidBST(root->left, min, &(root->val)) && isValidBST(root->right, &(root->val), max);
    }
};
```

### 3、leetcode0104 二叉树的最大深度（简单）

给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

解法1：递归

```c++
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (root == nullptr) {
            return 0;
        }

        return max(maxDepth(root->left), maxDepth(root->right)) + 1;
    }
};
```

### 4、leetcode0105 从前序与中序遍历序列构造二叉树（中等）

给定两个整数数组preorder和inorder，其中preorder是二叉树的先序遍历，inorder是同一棵树的中序遍历，请构造二叉树并返回其根节点。

解法1：递归

```c++
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        return buildTree(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1);
    }

private:
    TreeNode* buildTree(vector<int>& preorder, int preLeft, int preRight, 
        vector<int>& inorder, int inLeft, int inRight) {
        if (preLeft > preRight) {
            return nullptr;
        }

        TreeNode* root = new TreeNode(preorder[preLeft]);
        assert(root != nullptr);
        int cnt = 0;  // 获取下一个前序遍历的空间个数
        while (preorder[preLeft] != inorder[inLeft + cnt]) {
            ++cnt;
        }

        root->left = buildTree(preorder, preLeft + 1, preLeft + cnt, inorder, inLeft, inLeft + cnt - 1);
        root->right = buildTree(preorder, preLeft + cnt + 1, preRight, inorder, inLeft + cnt + 1, inRight);

        return root;
    }
};
```

### 5、leetcode0106 从中序与后序遍历序列构造二叉树（中等）

给定两个整数数组inorder和postorder，其中inorder是二叉树的中序遍历，postorder是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。

解法1：递归

```c++
class Solution {
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        return buildTree(inorder, 0, inorder.size() - 1, postorder, 0, postorder.size() - 1);
    }

private:
    TreeNode* buildTree(vector<int>& inorder, int inLeft, int inRight,
        vector<int>& postorder, int postLeft, int postRight) {
        if (postLeft > postRight) {
            return nullptr;
        }

        TreeNode* root = new TreeNode(postorder[postRight]);
        assert(root != nullptr);

        int cnt = 0;  // 获取下一个后续遍历的空间个数
        while (postorder[postRight] != inorder[inLeft + cnt]) {
            ++cnt;
        }

        root->left = buildTree(inorder, inLeft, inLeft + cnt - 1, postorder, postLeft, postLeft + cnt - 1);
        root->right = buildTree(inorder, inLeft + cnt + 1, inRight, postorder, postLeft + cnt, postRight - 1);

        return root;
    }
};
```



# N叉树

## 实践

### 1、leetcode0589 N 叉树的前序遍历（中等）

给定一个 n 叉树的根节点 root，返回 其节点值的前序遍历 。n叉树在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔。

解法1：递归，对于树的遍历，采用DFS(Depth First Search)深度优先搜索进行递归搜索的代码非常简单。

```c++
class Solution {
public:
    vector<int> preorder(Node* root) {
        vector<int> ans{};
        dfs(root, ans);
        return ans;
    }

private:
    void dfs(Node* root, vector<int>& ans) {
        if (root == nullptr) {
            return;
        }

        ans.push_back(root->val);
        for (auto node : root->children) {
            dfs(node, ans);
        }
    }
};
```

解法2：迭代，对于树的遍历，可借助一个临时的栈进行代码编写。

```c++
class Solution {
public:
    vector<int> preorder(Node* root) {
        if (root == nullptr) {
            return {};
        }

        vector<int> ans{};
        stack<Node*> stack{};
        stack.push(root);
        while (!stack.empty()) {
            auto node = stack.top();
            stack.pop();
            assert(node != nullptr);
            ans.push_back(node->val);
            // 由于栈后进先出，因此节点需要由后往前将孩子节点压入至栈中
            for (int i = node->children.size() - 1; i >= 0; --i) {
                if (node->children[i] != nullptr) {
                    stack.push(node->children[i]);
                }
            }
        }

        return ans;
    }
};
```

### 2、leetcode0429 N叉树的层序遍历（中等）

给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。

解法：基于BFS(Breadth First Search)广度优先搜索并借助队列实现层序遍历。cpp代码如下：

```c++
class Solution {
public:
    vector<vector<int>> levelOrder(Node* root) {
        vector<vector<int>> ans{};
        if (root == nullptr) {
            return ans;
        }
        bfs(root, ans);
        return ans;
    }

private:
    void bfs(Node* root, vector<vector<int>>& ans) {
        deque<Node*> deque{};
        deque.push_back(root);
        vector<int> subAns{};
        while (!deque.empty()) {
            subAns.clear();
            int levelSize = deque.size();  // 注意：需要保存队列个数，否则对每个节点操作后会更改队列
            for (int i = 0; i < levelSize; ++i) {
                auto node = deque.front();
                deque.pop_front();
                assert(node != nullptr);
                subAns.push_back(node->val);
                for (auto child : node->children) {
                    if (child != nullptr) {
                        deque.push_back(child);
                    }
                }
            }
            ans.push_back(subAns);
        }
    }
};
```

# 图

## 实践

### 1、leetcode0207 课程表（中等）

你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。在选修某些课程之前需要一些先修课程。先修课程按数组prerequisites给出，其中prerequisites[i] = [a~i~, b~i~] ，表示如果要学习课程a~i~则必须先学习课程b~i~ 。

例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。

请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。

解法：通过图的**拓扑排序**（基于广度优先搜索）实现课程表的创建，然后比较课程表的数量是否与必须选修的课程数量一致即可。

```c++
class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        to_.resize(numCourses);
        inDegree_.resize(numCourses);
        
        for (const auto& item : prerequisites) {
            to_[item.back()].push_back(item.front());
            inDegree_[item.front()]++;
        }

        queue<int> queue{};
        for (int course = 0; course < numCourses; ++course) {
            if (inDegree_[course] == 0) {
                queue.push(course);
            }
        }

        vector<int> courses{};
        courses.reserve(numCourses);
        while (!queue.empty()) {
            courses.push_back(queue.front());
            queue.pop();
            for (auto course : to_[courses.back()]) {
                inDegree_[course]--;
                if (inDegree_[course] == 0) {
                    queue.push(course);
                }
            }
        }

        return (courses.size() == numCourses);
    }

private:
    vector<vector<int>> to_;
    vector<int> inDegree_;
};
```

### 2、leetcode0684 冗余连接

树可以看成是一个连通且无环的**无向图**。给定往一棵 n 个节点 (节点值 1～n) 的树中添加一条边后的图。添加的边的两个顶点包含在 1 到 n 中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为n的二维数组edges，edges[i] = [a~i~, b~i~] 表示图中在a~i~和b~i~之间存在一条边。

请找出一条可以删去的边，删除后可使得剩余部分是一个有着n个节点的树。如果有多个答案，则返回数组 edges 中最后出现的边。

解法：基于深度优先搜索判断是否是一个图，如果为图则删除掉该条边即可。

```c++
class Solution {
public:
    vector<int> findRedundantConnection(vector<vector<int>>& edges) {
        int cnt = 0;
        for (const auto& edge : edges) {
            cnt = max(cnt, max(edge.front(), edge.back()));
        }

        to_.resize(cnt + 1);
        visited_.resize(cnt + 1);

        for (const auto& edge : edges) {
            to_[edge.front()].push_back(edge.back());
            to_[edge.back()].push_back(edge.front());
            dfs(edge.front(), 0);
            if (cycle_flag_) {
                return edge;
            }
        }

        return {};
    }

private:
    void dfs(int point, int father) {
        visited_[point] = true;
        for (int child : to_[point]) {
            if (child == father) {
                continue;  // 如果指向自己的父亲，需要过滤掉
            }

            if (!visited_[child]) {
                dfs(child, point);
            } else {
                cycle_flag_ = true;
            }
        }
        visited_[point] = false;
    }

    vector<vector<int>> to_;
    vector<bool> visited_;
    bool cycle_flag_{false};
};
```





# 分治

## 实践

### 1、leecode0050 Pow(x, n)（中等）

实现 pow(x, n) ，即计算 x 的整数 n 次幂函数（即，x^n^ ）。

注意：

- -100.0 < x < 100.0
- -2^31^ <= n <= 2^31^-1
- -10^4^ <= x^n^ <= 10^4^

解法1：由于n的取值范围为[-2^31^, 2^31^-1]，如果一个个值相乘那么时间复杂度为O(n)，但是由于n的值可能会很大，那么会导致执行超时。因此，该问题不能用简单粗暴的直接求解。在求解过程中，如果n大于0，x^n^ = x^n/2^ * x^n/2^，在这期间存在重复的子问题，此时可通过分治算法对问题进行求解。

```c++
class Solution {
public:
    double myPow(double x, int n) {
        return recur(x, n);
    }

    // 考虑到参数n的左边界，需要将参数从int类型提升到long long类型
    double recur(double x, long long n) {  
        if (n == 0) {
            return 1.0;
        }

        if (n < 0) {
            return 1.0 / recur(x, -n);
        }

        double ans = recur(x, n / 2);
        
        return (n % 2 == 0) ? (ans * ans) : (ans * ans * x);
    }
};
```

当然针对最小边界值，也可以进行值的特殊判断处理，代码如下：

```c++
class Solution {
public:
    double myPow(double x, int n) {
        if (n == 0) {
            return 1.0;
        }

        // 针对最小边界值进行特殊处理
        if (n == numeric_limits<int>::min()) {
            return myPow(x, n + 1) / x;
        }

        if (n < 0) {
            return 1.0 / myPow(x, -n);
        }

        double ans = myPow(x, n / 2);
        return (n % 2 == 0) ? (ans * ans) : (ans * ans * x);
    }
};
```

### 2、leetcode0022 括号生成（中等）

数字n代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且有效的括号组合。注意：`1 <= n <= 8`

解法1：将括号生成想象成```(A)B```的类型，这样A和B的获取就可以通过重复子问题去获取。注意，递归由上而下，可以通过记忆化搜索保存中间结果，避免子问题重复求解。

```c++
class Solution {
public:
    vector<string> generateParenthesis(int n) {
        if (n == 0) {
            return {""};
        }

        auto it = buffer_.find(n);
        if (it != buffer_.end()) {
            return it->second;
        }

        vector<string> ans{};
        for (int i = 0; i < n; ++i) {
            vector<string> A = generateParenthesis(i);
            vector<string> B = generateParenthesis(n - 1 - i);
            for (const auto& a : A) {
                for (const auto& b : B) {
                    ans.push_back('(' + a + ')' + b);
                }
            }
        }

        buffer_[n] = ans;

        return ans;        
    }

private:
    unordered_map<int, vector<string>> buffer_;  // 记忆化搜索
};
```

### 3、leetcode0023 合并k个升序链表（困难）

题目：给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。

```
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6
```

提示：

- k == lists.length

- 0 <= k <= 10^4^
- 0 <= lists[i].length <= 500
- -10^4^ <= lists\[i][j] <= 10^4^
- lists[i] 按 升序 排列
- lists[i].length 的总和不超过 10^4^

解法：如果按序分别将两组升序链表进行合并，那么其时间复杂度为O(m^2^n)，其中m为链表集合的个数，n为每组链表的最大值。但是若按照分治的算法进行处理，其时间复杂度为O(logm*mn)。cpp代码如下：

```c++
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if (lists.empty()) {
            return nullptr;
        }

        return mergeKLists(lists, 0, lists.size() - 1);
    }

private:
    ListNode* mergeKLists(vector<ListNode*>& lists, int left, int right) {
        if (left == right) {
            return lists[left];
        }

        int mid = left + (right - left) / 2;
        ListNode* list1 = mergeKLists(lists, left, mid);
        ListNode* list2 = mergeKLists(lists, mid + 1, right);

        return mergeTwoLists(list1, list2);
    }

    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        unique_ptr<ListNode> dummy = make_unique<ListNode>();
        ListNode* node = dummy.get();
        while ((list1 != nullptr) || (list2 != nullptr)) {
            if ((list2 == nullptr) || ((list1 != nullptr) && (list1->val <= list2->val))) {
                node->next = list1;
                list1 = list1->next;
            } else {
                node->next = list2;
                list2 = list2->next;
            }
            node = node->next;
        }
        return dummy->next;
    }
};
```































































