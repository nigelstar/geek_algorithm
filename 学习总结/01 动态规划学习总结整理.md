# 动态规划学习总结

## 算法思路

动态规划是一种对问题的状态空间进行**分阶段、有顺序、不重复、决策性**遍历的算法。

动态规划三要素：**阶段、状态、决策**。动态规划基于不同的最优状态进行决策，从当前阶段的最优状态转移至下一个阶段的最优状态。动态规划的本质是**对状态空间的有序不重复遍历**，相当于在以状态为点的图上进行拓扑排序。

动态规划典型应用场景：

- **重叠子问题**：与递归类似，问题存在相同的同类子问题
- **最优子结构**：每个状态都对应着一个最优化结果，并且在不同状态之间存在推导关系
- **无后向性**：问题的状态空间是一张有向无环图

动态规划推荐使用递推方式实现，代码相对比较简洁，耗费空间少。也可以使用递归，注意需要保存状态，保证每个状态只需遍历一次，又被称为记忆化搜索。

## 算法优化

### 转移优化思想

在动态规划中，如果有两层循环，外层循环i是状态变量，内层循环j是决策变量。此时，可分离状态变量和决策变量，对于一个状态变量，决策变量的取值范围被称为“决策候选集合”，可通过观察这个集合随着状态变量的变化情况。一旦发现冗余，可通过算法优化从而省去一层循环扫描。

## 典型应用场景

### 1、0/1背包

**给定N个物品，其中第i个物品的体积为V~i~，价值为W~i~。**有一容积为M的背包，要求选择一些物品放入背包，使得物品总体积不超过M的前提下，物品的价值总和最大。

F[i, j]表示从前i个物品中选出了总体积为j的物品放入到背包中，物品的最大价值和如下：

F[i, j] = max(F[i - 1, j], F[i - 1, j-V~i~] + W~i~)

初值：F[0, 0] = 0

目标：max~0≤j≤M~{`F[N][j]`}

典型代码：

```c++
vector<int> dp(m + 1, -10e9);  // 通过一维数组dp保存每个体积背包的价值总和
f[0] = 0;  // 设置初始值

for (int i = 0; i < n; ++i) {
	for (int j = m; j >= v[i]; --j) {  // j必须要倒序，依赖明确的子问题
        dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
    }
}

int ans = *max_element(dp.begin(), dp.end(), 0);
```

### 2、完全背包

**给定N种物品，其中第i种物品的体积为V~i~，价值为W~i~，并且有无数个。**有一容积为M的背包，要求选择一些物品放入背包，使得物品总体积不超过M的前提下，物品的价值总和最大。

F[i, j]表示从前i种物品中选出了总体积为j的物品放入到背包中，物品的最大价值和如下：

F[i, j] = max(F[i - 1, j], F[i, j-V~i~] + W~i~)

初值：F[0, 0] = 0

目标：max~0≤j≤M~{`F[N][j]`}

```c++
vector<int> dp(m + 1, -10e9);  // 通过一维数组dp保存每个背包体积下的价值总和
f[0] = 0;  // 设置初始值

for (int i = 0; i < n; ++i) {
	for (int j = v[i]; j <= m; ++j) {  // j必须要正序
        dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
    }
}

int ans = *max_element(dp.begin(), dp.end(), 0);
```

## 典型题目

### 1、零钱兑换

题目：给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。你可以认为每种硬币的数量是无限的。

限制条件：

- 1 <= coins.length <= 12
- 1 <= coins[i] <= 2^31^ - 1
- 0 <= amount <= 10^4^

思路：针对零钱兑换，可通过**动态规划**自下而上对可以凑成每个金额所需的最少硬币个数进行递推求解。

解题方法：

1、初始化。创建类型为`vector<int>`，个数为`amount + 1`的数组`dp`保存总金额区间[0, amount]每个金额所需的最少硬币个数，因为需要求最小值，将默认值全部设置为`int`类型的最大值；

2、设置边界值。当总金额为0时，无法兑换硬币，那么其初始值为0；

3、最优状态转移。通过状态转移方程依次获取每个总金额对应的最小硬币数。如果该总金额无法通过硬币兑换，将结果值设置为-1。在状态转移处理过程中，需要注意如下几点：

- 数组访问的有效性；
- 若前一个状态无有效解，那么不能基于该状态进行决策。

4、获取结果。将凑成总金额为amount的最少硬币个数作为最终结果。

复杂度：

- 时间复杂度：$O(m * n)$，m为amount金额，n为硬币的种类数
- 空间复杂度：$O(m)$，m为amount金额

代码：

```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> dp(amount + 1, numeric_limits<int>::max());  // 初始化  
        dp[0] = 0;  // 设置边界值
        // 最优状态转移，依次获取每个总金额对应的最小硬币数
        for (int i = 1; i <= amount; ++i) {
            for (int coin : coins) {
                // 若该硬币不超过金额且减去该硬币后的剩余金额存在最优解，可通过状态转换方程进行求解
                if ((i - coin >= 0) && (dp[i - coin] != -1)) {
                    dp[i] = min(dp[i], dp[i - coin] + 1);
                }
            }
            // 如果该总金额无法兑换为硬币，将结果设置为-1
            if (dp[i] == numeric_limits<int>::max()) {
                dp[i] = -1;
            }
        }
        return dp[amount];
    }
};
```

### 2、不同路径（无障碍物）

题目：一个机器人位于一个 `m x n` 网格的左上角，机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角，总共有多少条不同的路径。

限制条件：

- 1 <= m, n <= 100
- 题目数据保证答案小于等于 2 * 10^9^

思路：

由于机器人每次只能向下或者向右移动一步，那么每个网格只能从左边或者上方移动来，其路径条数为达到该网格左边和上方的路径和，通过动态规划获取机器人从网格左上角到达当前网格的路径数。

解题方法：

1、初始化。创建类型为`vector<vector<int>>`，个数为`m * n`的二维数组`dp`保存从左上角到当前每个网格的不同路径条数，将其初始值设置为1；

2、设置边界值。由于机器人只能向下或者向右移动，那么与左上角网格水平或者垂直的路径数有且只有1条。由于在第一步初始化时将二维数组的初始值设置为1，已经完成了边界值的设置。

3、最优状态转移。通过状态转移方程`dp[i][j] = dp[i - 1][j] + dp[i][j - 1]`获取每个非边界网格的路径数。

4、获取结果。将左上角到右下角网格的路径数`dp[m-1][n-1]`作为最终结果。

复杂度：

- 时间复杂度：$O(m*n)$，`m * n`为网格的个数
- 空间复杂度：$O(m*n)$，`m * n`为网格的个数，依赖二维数组保存从左上角到当前每个网格的不同路径条数

代码：

```c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m, vector<int>(n, 1));
        for (int i = 1; i < m; ++i) {
            for (int j = 1; j < n; ++j) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
};
```

### 3、不同路径（有障碍物）

题目：一个机器人位于一个 `m x n` 网格的左上角，机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角，总共有多少条不同的路径。注意：在网格中存在障碍物，网格中的障碍物和空位置分别用1和0来表示。

限制条件：

- m = obstacleGrid.length
- n = obstacleGrid[i].length
- 1 <= m, n <= 100
- `obstacleGrid[i][j]`为0或1

思路：

和上题类似，由于机器人每次只能向下或者向右移动一步，那么每个网格只能从左边或者上方移动来，其路径条数为达到该网格左边和上方的路径和，通过动态规划获取机器人从网格左上角到达当前网格的路径数。

但是，在本题中多了一个限制条件是存在障碍物，如果网格中存在障碍物那么将无法到达该网格，同时题目也未限定答案的值类型为`int`，需要通过类型为`long long`进行保存结果集。

解题方法：

1、特殊条件过滤判断。如果左上角或者右下角存在障碍物，那么直接返回路径条数为0。

2、初始化。创建类型为`vector<vector<long long>>`，个数为`m * n`的二维数组`dp`保存从左上角到当前每个网格的不同路径条数，将其初始值设置为0。

3、设置边界值。将左上角网格的初始值设置为1，分别对左上角网格水平或者垂直的网格遍历处理。若该网格存在障碍物，那么需要将路径数设置为0。

4、最优状态转移。通过状态转移方程`dp[i][j] = dp[i - 1][j] + dp[i][j - 1]`获取每个非边界网格的路径数。若该网格存在障碍物，那么需要将路径数设置为0。

5、获取结果。将左上角到右下角网格的路径数`dp[m-1][n-1]`作为最终结果。

复杂度：

- 时间复杂度：$O(m*n)$，`m * n`为网格的个数。
- 空间复杂度：$O(m*n)$，`m * n`为网格的个数，依赖二维数组保存从左上角到当前每个网格的不同路径条数。

代码：

```c++
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        // 1. 特殊条件过滤判断
        if ((obstacleGrid.front().front() == 1) || (obstacleGrid.back().back() == 1)) {
            return 0;
        }

        // 2. 初始化
        int m = obstacleGrid.size();
        int n = obstacleGrid.front().size();
        vector<vector<long long>> dp(m, vector<long long>(n, 0));

        // 3. 设置边界值
        dp[0][0] = 1;
        for (int i = 1; i < m; ++i) {
            dp[i][0] = (obstacleGrid[i][0] == 0) ? dp[i - 1][0] : 0;
        }
        for (int j = 1; j < n; ++j) {
            dp[0][j] = (obstacleGrid[0][j] == 0) ? dp[0][j - 1] : 0;
        }

        // 4. 最优状态转移
        for (int i = 1; i < m; ++i) {
            for (int j = 1; j < n; ++j) {
                dp[i][j] = (obstacleGrid[i][j] == 0) ? dp[i - 1][j] + dp[i][j - 1] : 0;
            }
        }

        // 5. 获取结果
        return dp[m - 1][n - 1];
    }
};
```

### 4、最长公共子序列

题目：给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ，返回 `0` 。

一个字符串的 **子序列** 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

两个字符串的 **公共子序列** 是这两个字符串所共同拥有的子序列。

限制条件：

- 1 <= text1.length, text2.length <= 1000
- text1和text2仅有小写英文字符组成

思路：

因为一个字符串的子序列存在2^n^种可能，如果对两个字符串的子序列同时进行穷举和比较，那么需要穷举的子序列个数将不计其数，时间复杂度很大。在本题中，只需要获取两个字符串的最长公共子序列的长度，可通过动态规划求解。

若使用动态规划，最主要的是状态转移方程的确认。针对两个字符串，其最长公共子序列的长度值变化如下图所示：以字符串abcde和acd为例。

|       |   a    |   ac    |   acd    |
| :---: | :----: | :-----: | :------: |
|   a   | 1（a） | 1（a）  |  1（a）  |
|  ab   | 1（a） | 1（a）  |  1（a）  |
|  abc  | 1（a） | 2（ac） | 2（ac）  |
| abcd  | 1（a） | 2（ac） | 3（acd） |
| abcde | 1（a） | 2（ac） | 3（acd） |



通过如上二维表格，每个表格中的数字表示当前两个子字符串的最大公共子序列的长度值。以`f[i, j]`表示text1的前i个字符和text2的前j个字符的最大公共子序列的长度，如果text1[i] == text2[j]，那么f[i, j] = f[i - 1, j - 1] + 1；如果text1[i] != text2[j]，f[i, j] = max(f[i - 1, j], f[i, j - 1])。

解题方法：

1、初始化。创建类型为`vector<vector<int>>`，个数为`(m + 1) * (n + 1)`的二维数组`dp`保存text1和text2的每个子字符串的最大公共子序列的长度值，将其初始值设置为0。

2、设置边界值。如果任一子字符串为空字符串，那么最大公共子序列的长度将为0，即`dp[0][j]`和`dp[i][0]`的值为0。因为初始化时将二维数组`dp`的初始值均设置为0，无需专门设置边界值。

3、最优状态转移。通过状态转移方程设置不同两个子字符串的最大公共子序列的长度值，转移方程为：

- 如果text1[i] == text2[j]，f[i, j] = f[i - 1, j - 1] + 1；
- 如果text1[i] != text2[j]，f[i, j] = max(f[i - 1, j], f[i, j - 1])。

4、获取结果。将二维数组最后一个值作为最终结果。

复杂度：

- 时间复杂度：$O(m*n)$，m、n分别为两个字符串的长度；
- 空间复杂度：$O(m*n)$，m、n分别为两个字符串的长度，依赖类型为`vector<vector<int>>`，个数为`(m + 1) * (n + 1)`的二维数组`dp`两个字符串所有子字符串的最大公共子序列长度。

代码：

```c++
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        // 初始化
        int m = text1.size();
        int n = text2.size();
        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));

        // 最优状态转移 
        for (int i = 1; i <= m; ++i) {
            for (int j = 1; j <= n; ++j) {
                if (text1[i - 1] == text2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }

        // 获取结果。将二维数组最后一个值作为最终结果。
        return dp[m][n];
    }
};
```

### 5、最长递增子序列

题目：给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

限制条件：

- 1 <= nums.length <= 2500
- -10^4^ <= nums[i] <= 10^4^

思路：

如果数组当前元素大于之前的元素值，那么其可以与当前元素值小的元素组成严格递增的子序列。本题可通过动态规划求解，遍历数组并不断获取该元素作为末尾元素的最长递增子序列的最大长度。

解题方法：

1、初始化。创建类型为`vector<int>`，个数为n为的一维数组`dp`保存每个元素作为末尾元素的最长递增子序列的最大长度，因为单个元素都可以作为一个递增子序列，那么将初始值设置为1。

2、最优状态转移。遍历整个数组，不断将元素与该元素之前的元素进行比较，若nums[i] > nums[j]，通过状态转移方程dp[i] = max(dp[i], dp[j] + 1)更新最优状态值。

3、获取结果。遍历一维数组`dp`中的最大值作为最终结果。

复杂度：

- 时间复杂度：$O(n^2)$，n为整数数组的个数。
- 空间复杂度：$O(n)$，n为整数数组的个数，依赖类型为`vector<int>`，个数为n为的一维数组`dp`保存每个元素作为末尾元素的最长递增子序列的最大长度。

代码：

```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int size = nums.size();
        vector<int> dp(size, 1);
        for (int i = 1; i < size; ++i) {
            for (int j = i - 1; j >= 0; --j) {
                if (nums[i] > nums[j]) {
                    dp[i] = max(dp[i], dp[j] + 1);
                }
            }
        }
        return *max_element(dp.begin(), dp.end());
    }
};
```

### 6、最大子数组和

题目：给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。**子数组** 是数组中的一个连续部分。

限制条件：

- 1 <= nums.length <= 10^5^
- -10^4^ <= nums[i] <= 10^4^

思路：

基于动态规划获取每个元素作为连续子数组末尾元素的最大和，返回每个子结果的最大值即可。

解题方法：

1、初始化。创建类型为`vector<int>`，元素个数为n的一维数组`dp`，其中一维数组`dp`完全拷贝至整数数组`nums`。

2、最优状态转移。通过状态转移方程`dp[i] = max(dp[i], dp[i - 1] + dp[i])`依次获取每个元素作为连续子数组末尾元素的最大和。

3、获取结果。遍历一维数组`dp`获取数组的最大值作为最终结果。

复杂度：

- 时间复杂度：$O(n)$，n为整数数组的个数。
- 空间复杂度：$O(n)$，n为整数数组的个数，依赖类型为`vector<int>`，个数为n为的一维数组`dp`保存每个元素作为连续子数组末尾元素的最大和。

代码：

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        vector<int> dp(nums);
        for (int i = 1; i < nums.size(); ++i) {
            dp[i] = max(dp[i - 1] + nums[i], nums[i]);
        }
        return *max_element(dp.begin(), dp.end());
    }
};
```

### 7、买卖股票的最佳时机（只能买卖一次）

题目：给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。

限制条件：

- 1 <= prices.length <= 10^5^
- 0 <= prices[i] <= 10^4^

思路：

由于股票只能买卖一次，为了获取最大利润，需要先在股票价格最低的时候买入，然后在股票价格最高的时候卖出，这样才能获取最大利润。

解题方法：

1、初始化。分别创建两个类型为`int`的临时变量，用于保存最大利润值和当前遇到的最低价格。

2、最优状态转移。轮询遍历每天的股票价格，不断更新最低价格和最大利润值。

3、获取结果。将最大利润值作为最终结果。

复杂度：

- 时间复杂度：$O(n)$，n为整数数组的个数
- 空间复杂度：$O(1)$。

代码：

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int max_profit = 0;
        int min_price = prices.front();
        for (int i = 1; i < prices.size(); ++i) {
            max_profit = max(max_profit, prices[i] - min_price);
            min_price = min(min_price, prices[i]);
        }
        return max_profit;
    }
};
```

### 8、买卖股票的最佳时机 II （能够买卖无限次）

题目：给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。返回 *你能获得的 **最大** 利润* 。

限制条件：

- 1 <= prices.length <= 3 * 10^4^
- 0 <= prices[i] <= 10^4^

思路：

由于获取买卖股票的最大利润，可以基于动态规划获取每天在持有/不持有股票的情况下的最大利润。

解题方法：

1、初始化。创建类型为`vector<vector<int>>`，个数为$n * 2$的二维数组`dp`，由于需要求最大利润，将初始值设置为`int`类型的最小值。

2、设置边界值。设置第一天的收益信息，由于第一天无法卖出股票，因此不持有股票的收益为0。第一天可以买入股票，持有股票的收益为-price。

3、最优状态转移。通过状态转移方程依次获取每一天在持有/不持有股票的情况下的最大收益。

4、获取结果。将最后一天未持有股票情况的利润作为最终结果。

复杂度：

- 时间复杂度：$O(n)$，n为整数数组的个数。
- 空间复杂度：$O(n)$，n为整数数组的个数，依赖类型为`vector<vector<int>>`，个数为$n * 2$的二维数组`dp`保存所有最优解。

代码：

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        // 初始化
        int size = prices.size();
        vector<vector<int>> dp(size, vector<int>(2, numeric_limits<int>::min()));

        // 设置边界条件
        dp[0][0] = 0;
        dp[0][1] = -prices.front();

        // 最优状态转移
        for (int i = 1; i < size; ++i) {
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);  
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);  
        }

        // 获取结果
        return dp[size - 1][0];
    }
};
```

### 9、买卖股票的最佳时机 III（最多只能买卖2次）

题目：给定一个数组，它的第 `i` 个元素是一支给定的股票在第 `i` 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 **两笔** 交易。**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

限制条件：

- 1 <= prices.length <= 10^5^
- 0 <= prices[i] <= 10^5^

思路：

本题与买卖股票的最佳时机II类似，但是多了一个限制条件是明确交易次数，需要在动态规划的基础上增加交易次数的维度。

解题方法：

1、初始化。创建类型为`vector<vector<vector<int>>>`，个数为$n * 2 * 2$的三维数组`dp`，由于需要求最大利润，将初始值设置为`int`类型的最小值。

2、设置边界值。设置第一天的收益信息，由于第一天无法卖出股票，因此不持有股票的收益为0。第一天可以买入股票，持有股票的收益为-price。

3、最优状态转移。通过状态转移方程依次获取每一天在持有/不持有股票的情况下交易k次的最大收益。

4、获取结果。遍历获取交易两次的股票收益最大值作为最终结果。

复杂度：

- 时间复杂度：$O(n)$，n为整数数组的个数。
- 空间复杂度：$O(n)$，n为整数数组的个数，依赖类型为`vector<vector<vector<int>>>`，个数为$n * 2 * 2$的三维数组`dp`保存所有最优解。

代码：

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        // 初始化
        int size = prices.size();
        vector<vector<vector<int>>> dp(size, vector<vector<int>>(2, vector<int>(2, numeric_limits<int>::min())));
        // 设置边界值
        dp[0][0][0] = 0;
        dp[0][1][0] = -prices.front();
        dp[0][0][1] = 0;
        dp[0][1][1] = -prices.front();

        // 最优状态转移
        for (int i = 1; i < size; ++i) {
            for (int j = 0; j < 2; ++j) {
                dp[i][0][j] = max(dp[i - 1][0][j], dp[i - 1][1][j] + prices[i]);
                if (j == 0) {
                    dp[i][1][j] = max(dp[i - 1][1][j], -prices[i]);
                } else {
                    dp[i][1][j] = max(dp[i - 1][1][j], dp[i - 1][0][j - 1] - prices[i]);
                }
            }
        }

        int max_profit = 0;
        for (int i = 0; i < size; ++i) {
            max_profit = max(max_profit, dp[i][0][1]);
        }

        return max_profit;
    }
};
```

### 10、

### 11、

### 12、

### 13、打家劫舍（房屋不成环）

题目：你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。

限制条件：

- 1 <= nums.length <= 100
- 0 <= nums[i] <= 400

思路：

通过动态规划获取小偷在每家房屋偷窃或者不偷窃的最高金额。

解题方法：

1、初始化。创建类型为`vector<vector<int>>`，个数为`n*2`的二维数组`dp`保存小偷在每家房屋偷窃或者不偷窃的最高金额，初始值设置为0。

2、设置边界值。设置小偷在第一家房屋偷窃或者不偷窃的金额。

3、最优状态转移。通过状态转移方程获取小偷在每家房屋偷窃或者不偷窃的最高金额。

4、获取结果。将最后一家房屋偷窃或者不偷窃的最高金额的较大值作为最终看结果。

复杂度：

- 时间复杂度：$O(n)$，n为房屋的间数。
- 空间复杂度：$O(n)$，n为房屋的间数，依赖类型为`vector<vector<int>>`，个数为`n*2`的二维数组`dp`保存小偷在每家房屋偷窃或者不偷窃的最高金额

代码：

```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        // 初始化
        int size = nums.size();
        vector<vector<int>> dp(size, vector<int>(2, 0));
        
        // 设置边界值
        dp[0][0] = 0;
        dp[0][1] = nums.front();

        // 最优状态转移
        for (int i = 1; i < size; ++i) {
            // 小偷不偷窃，此时最高金额为前一间房屋偷窃或者不偷窃的最高金额较大值
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1]);
            // 小偷偷窃，此时最高金额为前一间访问不偷窃的最高金额和当前房屋金额的和
            dp[i][1] = dp[i - 1][0] + nums[i];
        }

        // 获取结果
        return max(dp.back()[0], dp.back()[1]);
    }
};
```

### 14、打家劫舍（房屋成环）

题目：你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 **围成一圈** ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警** 。给定一个代表每个房屋存放金额的非负整数数组，计算你 **在不触动警报装置的情况下** ，今晚能够偷窃到的最高金额。

限制条件：

- 1 <= nums.length <= 100
- 0 <= nums[i] <= 1000

思路：

本题和打家劫舍（房屋不成环）类似，当时一个唯一的不同点就是房屋成环，这样如果偷了第一家，那么无法偷最后一家，否者同时偷第一家和最后一家，将会触动警报装置。

针对环形动态规划，可以分两次处理，一次是不偷第一家，然后获取最后一间房屋偷窃或者不偷窃的最高金额较大值，另外一次是偷第一家，或者最后一家房屋不偷窃的最高金额。

解题方法：

1、初始化。创建类型为`vector<vector<int>>`，个数为`n*2`的二维数组`dp`保存小偷在每家房屋偷窃或者不偷窃的最高金额，初始值设置为0。

2、第一轮DP处理，先不偷第一家，通过状态转移方程获取小偷在每家房屋偷窃或者不偷窃的最高金额，获取最后一家被偷窃或者不偷窃的最高值的较大值。

3、第二轮DP处理，再次偷第一家，通过状态转移方程获取小偷在每家房屋偷窃或者不偷窃的最高金额，获取最后一家未被偷窃的最高金额。

4、获取结果。将两轮DP处理的偷窃金额的最大值作为最终结果。

复杂度：

- 时间复杂度：$O(n)$，n为房屋的间数。
- 空间复杂度：$O(n)$，n为房屋的间数，依赖类型为`vector<vector<int>>`，个数为`n*2`的二维数组`dp`保存小偷在每家房屋偷窃或者不偷窃的最高金额

代码：

```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        // 初始化
        int size = nums.size();
        vector<vector<int>> dp(size, vector<int>(2, 0));

        // 第一轮动态规划，先不偷第一家
        dp[0][0] = 0;
        dp[0][1] = 0;

        for (int i = 1; i < size; ++i) {
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1]);
            dp[i][1] = dp[i - 1][0] + nums[i];
        }

        int result = max(dp.back()[0], dp.back()[1]);

        // 第二轮动态规划，偷第一家
        dp[0][0] = 0;
        dp[0][1] = nums[0];

        for (int i = 1; i < size; ++i) {
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1]);
            dp[i][1] = dp[i - 1][0] + nums[i];
        }

        result = max(result, dp.back()[0]);
        // 如果只有一家可偷窃，那么在偷第一家的时候需要将dp[0][1]的最高金额纳入到最终结果的统计中
        result = max(result, dp[0][1]);  

        // 获取结果
        return result;
    }
};
```

### 15、分割等和子集（0/1背包）

题目：给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

限制条件：

- 1 <= nums.length <= 200
- 1 <= nums[i] <= 100

思路：

如果将整个数组分割成两个元素和相等的子集，那么需要获取整个数组的元素和，如果其能被整除一半，才可能会存在有效的子集。接着通过0/1背包获取该有效的子集信息。

解题方法：

1、特殊条件过滤判断。如果整个数组的元素和无法被2整除，那么必定不存在有效解。

2、初始化。创建类型为`vector<bool>`，个数为`sum / 2 + 1`的一维数组`dp`，用于保存该子集和是否能够被分割，默认初始值为false。

3、设置边界值。将一维数组`dp`的首个元素设置为true，当子集和为0时，无需任何数组元素。

4、最优状态转移。二维遍历，一维遍历整个数组，二维逆序遍历子集和，如果元素值小于该子集和，那么决策该子集和是否被组合。

5、获取结果。将一维数组`dp`的末尾元素作为最终结果。

复杂度：

- 时间复杂度：$O(n * sum)$，依赖二维遍历，一维遍历长度为元素个数n，二维遍历长度为子集和 sum。
- 空间复杂度：$O(sum)$，依赖类型为`vector<bool>`，个数为`sum / 2 + 1`的一维数组`dp`，用于保存该子集和是否能够被分割。

代码：

```c++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        // 特殊条件过滤判断
        int sum = accumulate(nums.begin(), nums.end(), 0);
        if (sum % 2 != 0) {
            return false;
        }

        // 初始化
        vector<bool> dp(sum / 2 + 1, false);

        // 设置边界值
        dp.front() = true;

        // 最优状态转移
        for (int i = 0; i < nums.size(); ++i) {
            for (int j = sum / 2; j >= nums[i]; --j) {
                if (dp[j - nums[i]]) {
                    dp[j] = true;
                }
            }
            // 剪枝处理，如果子集和sum / 2已经可以被元素组合，那么无需继续后续的处理
            if (dp.back()) {
                return true;
            }
        }

        // 获取结果
        return dp.back();
    }
};
```

### 16、零钱兑换II（完全背包）

题目：给你一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 `amount` 表示总金额。请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 `0` 。假设每一种面额的硬币有无限个。 题目数据保证结果符合 32 位带符号整数。

限制条件：

- 1 <= coins.length <= 300
- 1 <= coins[i] <= 5000
- coins 中的所有值 互不相同
- 0 <= amount <= 5000

思路：

由于每种面额的金币有无限个，需要通过不同面额的硬币凑成总金额，属于典型的完全背包问题。可通过动态规划获取每种金额下的硬币组合数。

解题方法：

1、初始化。创建类型为`vector<int>`，个数为`amount + 1`为的一维数组`dp`，用于保存不同总金额下的硬币组合数，将初始值默认设置为0。

2、设置边界值。当不选取任何硬币时，金额之和为0，因此将一维数组`dp`的首个元素dp[0]设置为1。

3、最优状态转移。遍历不同面额金币，通过转移方程`dp[i] += dp[i - coin]`获取每种总金额的硬币组合数。

4、获取结果。将一维数组`dp`的末尾元素作为最终结果。

复杂度：

- 时间复杂度：$O(amount * n)$，amount为总金额，n为不同面额的金币个数。
- 空间复杂度：$O(amount)$，amount为总金额，需要创建类型为`vector<int>`，个数为`amount + 1`为的一维数组`dp`，用于保存不同总金额下的硬币组合数。

代码：

```c++
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        vector<int> dp(amount + 1, 0);
        dp[0] = 1;
        for (int coin : coins) {
            for (int i = coin; i <= amount; ++i) {
                dp[i] += dp[i - coin];
            }
        }
        return dp.back();
    }
};
```

### 17、完全平方数（完全背包）

题目：给你一个整数 `n` ，返回 *和为 `n` 的完全平方数的最少数量* 。**完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是。

限制条件：1 <= n <= 10^4^

思路：

本题可简化为**完全背包**问题，通过对不同完全平方数求和得到一个给定整数的最少数量。

解题方法：

1、初始化。创建类型为`vector<int>`，个数为`n + 1`的一维数组`dp`，用于保存在和为不同整数下所需完全平方数的最少数量。由于需要求最小值，将初始值默认设置为类型为`int`的最大值。

2、设置边界值。当和为0时，无需任何平方数，将dp[0]设置为0；

3、最优状态转移。从1开始遍历，分别获取不同整数下所需平方数的最少数量。

4、获取结果。如果一维数组`dp`的末尾元素为`int`的最大值，无有效值，将最终结果设置为0，否则直接将`dp`的末尾元素设置为最终结果。

复杂度：

- 时间复杂度：$O(nlogn)$，n为给定的正整数，需要遍历范围[1, n]内的所有平方数。
- 空间复杂度：$O(n)$，n为给定的正整数，依赖类型为`vector<int>`，个数为`n + 1`的一维数组`dp`，用于保存在和为不同整数下所需完全平方数的最少数量。

代码：

```c++
class Solution {
public:
    int numSquares(int n) {
        vector<int> dp(n + 1, numeric_limits<int>::max());
        dp[0] = 0;
        for (int i = 1; i <= n; ++i) {
            int square = i * i; 
            for (int j = square; j <= n; ++j) {
                if (dp[j - square] != numeric_limits<int>::max()) {
                    dp[j] = min(dp[j], dp[j - square] + 1);
                }
            }
        }
        return (dp.back() != numeric_limits<int>::max()) ? dp.back() : 0;
    }
};
```







































