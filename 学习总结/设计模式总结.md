# 面向对象设计模式学习总结

## 目标

- 理解**松耦合设计**思想
- 掌握**面向对象设计原则**
- 掌握**重构技法**改善设计
- 掌握GOF**核心设计模式**

什么是好的软件设计？软件设计的金科玉律？应对变化，提高**复用**

## 常见概念

设计模式：每一个模式描述了一个在我们周围**不断重复发生的问题**，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动。

面向对象：如何理解面向对象，可分为如下几个方面：

- 向下：深入理解面向对象的三大特点
  - 封装：隐藏内部实现
  - 继承：复用现有代码
  - 多态：运行期改写对象行为
- 向上：把握面向对象机制所带来的抽象意义，理解如何使用这些机制来表达现实世界，掌握什么是“好的面向对象设计”

软件复杂的根本原因：各种各样的**变化**

如何解决软件的复杂性？

- 分解：分而治之，将大问题分解为多个小问题，将复杂问题分解为多个简单问题
- 抽象：因为不能掌握全部的复杂对象，选择忽视它的非本质细节，而去处理泛化和理想化了的对象模型

面向对象设计最大的优势：**抵御变化**，将变化的影响范围降至最小

- 隔离变化：构建方式更能适应软件的变化，将变化所带来的影响减为最小
- 各自其职：需求变化导致的新增类型不影响原来类型的实现
- 对象是什么？
  - 语言层面：对象封装了代码和数据
  - 规格层面：对象是一系列可被使用的公共接口
  - 概念层面：某种拥有责任的抽象

## 面向对象设计原则

### 1、依赖倒置原则（DIP）

- 高层模块（稳定）不应该依赖于低层模块（变化），二者都应该依赖于抽象（稳定）
- 抽象（稳定）不应该依赖于实现细节（变化），实现细节（变化）应该依赖于抽象（稳定）	

### 2、开放封闭原则（OCP）

- 对扩展开发，对更改封闭
- 类模块应该是可扩展的，但是不可修改

当新增需求时，应该增加一些代码而非修改已有代码来满足需求

### 3、单一职责原则（SRP）

- 一个类应该仅有一个引起它变化的原因
- 变化的方向隐含着类的责任

### 4、Liskov替换原则（LSP）

- 子类必须能够替换它们的基类
- 基础表达类型抽象

### 5、接口隔离原则（ISP）

- 不应该强迫客户程序依赖它们不用的方法
- 接口应该小而完备

### 6、优先使用对象组合而非继承

对象关系：

组合（composition），has-a，生命周期一致，构造由内而外，析构由外而内。

委托（delegation），composition by reference，生命周期不一致。

继承（inheritance），is-a，生命周期一致，构造由内而外，析构由外而内，父类析构函数必须是virtual。

虚函数表相关内容整理？？？

inheritance + composition 关系下的构造和析构？？？构造顺序是什么样子的？ 

- 对象组合（has-a）：**黑箱**复用。  类继承（is-a）：**白箱**复用。
- 继承在某种程度上破坏了封装性，子类父类耦合度高。
- 对象组合只要求被组合的对象具有良好定义的接口，低耦合。

### 7、封装变化点

- 使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响。

### 8、针对接口而非实现编程

- 不将变量类型声明为某个特性的具体类，而是声明为某个接口（主要针对业务模块）
- 客户程序无需获知对象的具体类型，只知道对象所具有的接口
- 减少系统中各部分的依赖关系，实现“高内聚、松耦合”

### 现实场景：

活字印刷术：将每个字单独印刷，然后自由组合，重复使用。

## 设计模式

### 模式分类

- 创建型：
- 结构型：
- 行为型：

### 模式应用：重构获得模式

设计模式的关键点是寻找变化点，在变化点处应用设计模式，从而来更好的应对需求的变化。**对于开发者，在什么时候，什么地点应用设计模式比理解设计模式结构本身更加重要**。

没有一步到位的设计模式，重构获得模式是目前普遍公认的最好的使用设计模式的方法。

### 重构关键点：

- 静态 → 动态
- 早绑定 → 晚绑定
- 继承 → 组合
- 编译时依赖 → 运行时依赖
- 紧耦合 → 松耦合









































