# 数组&链表

数组：在内存中是**一段连续**的存储空间，可支持随机访问。

时间复杂度：

|   操作   | 时间复杂度 |
| :------: | :--------: |
|   查询   |    O(1)    |
|   插入   |    O(n)    |
|   删除   |    O(n)    |
| 尾部插入 |    O(1)    |
| 头部插入 |    O(n)    |



## 数组&链表问题

1、数组和链表的相同和差异点？

2、变长数组如何设计？

## 典型应用场景

### 1、过滤器思想

遍历数组，将满足条件的元素放入至结果集合中，**常用于数组的保序操作处理**。代码模板如下：

```c++
for (int i = 1; i < nums.size(); ++i) {
    if (condition) {  // 过滤器
		// 满足过滤器判断后，结果集合处理
    }
}
```

## 典型题目

### 1、删除有序数组中的重复项（过滤器思想）

题目：给你一个 **升序排列** 的数组 `nums` ，请你**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 `k` 个元素，那么 `nums` 的前 `k` 个元素应该保存最终结果。将最终结果插入 `nums` 的前 `k` 个位置后返回 `k` 。

不要使用额外的空间，你必须在 **[原地 ](https://baike.baidu.com/item/原地算法)修改输入数组** 并在使用 O(1) 额外空间的条件下完成。

限制条件：

- 1 <= nums.length <= 3 * 10^4^
- -10^4^ <= nums[i] <= 10^4^
- nums 已按 升序 排列

思路：

遍历有序数组，在遍历数组过程中可通过**过滤器**的思想将满足条件的元素保存至结果集合中。

解题方法：

1、初始化。初始化类型为`int`的临时变量size，用于保存数组的新长度，将size初始值设置为1，因为数组第一个元素肯定是非重复的。

2、数组遍历，过滤条件。从索引为1开始遍历数组，如果该元素值和前一个元素值相等，则不能将其放入至结果集合中。否则，将其放入至结果集合中，因为要原地修改输入数组，则直接将值保存至输入数组中，并且同时更新临时变量size。

3、设置结果。将临时变量size作为最终结果。

复杂度：

- 时间复杂度：$O(n)$，需要遍历数组。
- 空间复杂度：$O(1)$，无需额外空间保存结果。

代码：

```c++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int size = 1;
        for (int i = 1; i < nums.size(); ++i) {
            if (nums[i] != nums[i - 1]) {  // 过滤器，如果前后两个元素值不相等，才能将结果保存至结果集合中
                nums[size] = nums[i];
                ++size;
            }
        }
        return size;
    }
};
```

### 2、移动零（过滤器思想）

题目：给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

限制条件：

- 1 <= nums.length <= 10^4^
- -2^31^ <= nums[i] <= 2^31^ - 1

思路：

遍历数组，当元素非0时才将元素保存至结果集合中，当遍历完后再将结果集合尾部的元素设置为0。

解题方法：

1、初始化。初始化类型为`int`的临时变量size，用于保存非零元素的数组长度，将size初始值设置为0。

2、遍历数组，过滤条件。从索引为0开始遍历数组，如果元素值非0，将其放入至结果集合中，并且同时更新size。

3、遍历完数组后，更新尾部元素值为0。当遍历完数组后，输入数组在区间[0, size)值不为0，需要将输入数组区间[size, nums.size())更新为0。

复杂度：

- 时间复杂度：$O(n)$，需要遍历数组。
- 空间复杂度：$O(1)$，无需额外空间保存结果。

代码：

```c++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int size = 0;
        for (int i = 0; i < nums.size(); ++i) {
            if (nums[i] != 0) {
                nums[size] = nums[i];
                ++size;
            }
        }
        while (size < nums.size()) {
            nums[size] = 0;
            ++size;
        }
    }
};
```

### 3、合并两个有序数组

题目：给你两个按 **非递减顺序** 排列的整数数组 `nums1` 和 `nums2`，另有两个整数 `m` 和 `n` ，分别表示 `nums1` 和 `nums2` 中的元素数目。请你 **合并** `nums2` 到 `nums1` 中，使合并后的数组同样按 **非递减顺序** 排列。

**注意：**最终，合并后数组不应由函数返回，而是存储在数组 `nums1` 中。为了应对这种情况，`nums1` 的初始长度为 `m + n`，其中前 `m` 个元素表示应合并的元素，后 `n` 个元素为 `0` ，应忽略。`nums2` 的长度为 `n` 。

限制条件：

- nums1.length == m + n
- nums2.length == n
- 0 <= m, n <= 200
- 1 <= m + n <= 200
- -10^9^ <= nums1[i], nums2[j] <= 10^9^

思路：

倒序将两个数组进行合并处理。

解题方法：

1、初始化。创建类型为`int`的`i`，`j`，`k`三个临时变量用于保存数组索引，分别将其初始值设置为m - 1，n - 1，m + n - 1。

2、倒序遍历数组。倒序遍历数组，将结果保存至数组`nums1`中。注意边界条件的判断处理

复杂度：

- 时间复杂度：$O(m + n)$，需要遍历两个数组的所有元素。
- 空间复杂度：$O(1)$，无需额外空间保存结果。

代码：

```c++
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int i = m - 1;
        int j = n - 1;
        int k = m + n - 1;
        while ((i >= 0) || (j >= 0)) {
            if ((j < 0) || ((i >= 0) && (nums1[i] >= nums2[j]))) {
                nums1[k] = nums1[i];
                --i;
            } else {
                nums1[k] = nums2[j];
                --j;
            }
            --k;
        }
    }
};
```

举一反三：

1、为什么倒序遍历处理数据不会有问题，但是正序处理数据存在问题？

2、该处理和归并排序的归并处理非常类似，在归并排序时可以重点关注归并的操作处理。





